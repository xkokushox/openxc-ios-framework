// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source file openxc.proto

import Foundation
import ProtocolBuffers

// FIXME: Change all setter methods, they return object

public func == (lhs: VehicleMessage, rhs: VehicleMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
  fieldCheck = fieldCheck && (lhs.hasCanMessage == rhs.hasCanMessage) && (!lhs.hasCanMessage || lhs.canMessage == rhs.canMessage)
  fieldCheck = fieldCheck && (lhs.hasSimpleMessage == rhs.hasSimpleMessage) && (!lhs.hasSimpleMessage || lhs.simpleMessage == rhs.simpleMessage)
  fieldCheck = fieldCheck && (lhs.hasDiagnosticResponse == rhs.hasDiagnosticResponse) && (!lhs.hasDiagnosticResponse || lhs.diagnosticResponse == rhs.diagnosticResponse)
  fieldCheck = fieldCheck && (lhs.hasControlCommand == rhs.hasControlCommand) && (!lhs.hasControlCommand || lhs.controlCommand == rhs.controlCommand)
  fieldCheck = fieldCheck && (lhs.hasCommandResponse == rhs.hasCommandResponse) && (!lhs.hasCommandResponse || lhs.commandResponse == rhs.commandResponse)
  fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: CanMessage, rhs: CanMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasBus == rhs.hasBus) && (!lhs.hasBus || lhs.bus == rhs.bus)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
  fieldCheck = fieldCheck && (lhs.hasFrameFormat == rhs.hasFrameFormat) && (!lhs.hasFrameFormat || lhs.frameFormat == rhs.frameFormat)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ControlCommand, rhs: ControlCommand) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
  fieldCheck = fieldCheck && (lhs.hasDiagnosticRequest == rhs.hasDiagnosticRequest) && (!lhs.hasDiagnosticRequest || lhs.diagnosticRequest == rhs.diagnosticRequest)
  fieldCheck = fieldCheck && (lhs.hasPassthroughModeRequest == rhs.hasPassthroughModeRequest) && (!lhs.hasPassthroughModeRequest || lhs.passthroughModeRequest == rhs.passthroughModeRequest)
  fieldCheck = fieldCheck && (lhs.hasAcceptanceFilterBypassCommand == rhs.hasAcceptanceFilterBypassCommand) && (!lhs.hasAcceptanceFilterBypassCommand || lhs.acceptanceFilterBypassCommand == rhs.acceptanceFilterBypassCommand)
  fieldCheck = fieldCheck && (lhs.hasPayloadFormatCommand == rhs.hasPayloadFormatCommand) && (!lhs.hasPayloadFormatCommand || lhs.payloadFormatCommand == rhs.payloadFormatCommand)
  fieldCheck = fieldCheck && (lhs.hasPredefinedObd2RequestsCommand == rhs.hasPredefinedObd2RequestsCommand) && (!lhs.hasPredefinedObd2RequestsCommand || lhs.predefinedObd2RequestsCommand == rhs.predefinedObd2RequestsCommand)
  fieldCheck = fieldCheck && (lhs.hasModemConfigurationCommand == rhs.hasModemConfigurationCommand) && (!lhs.hasModemConfigurationCommand || lhs.modemConfigurationCommand == rhs.modemConfigurationCommand)
  fieldCheck = fieldCheck && (lhs.hasRtcConfigurationCommand == rhs.hasRtcConfigurationCommand) && (!lhs.hasRtcConfigurationCommand || lhs.rtcConfigurationCommand == rhs.rtcConfigurationCommand)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: DiagnosticControlCommand, rhs: DiagnosticControlCommand) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasRequest == rhs.hasRequest) && (!lhs.hasRequest || lhs.request == rhs.request)
  fieldCheck = fieldCheck && (lhs.hasAction == rhs.hasAction) && (!lhs.hasAction || lhs.action == rhs.action)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PassthroughModeControlCommand, rhs: PassthroughModeControlCommand) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasBus == rhs.hasBus) && (!lhs.hasBus || lhs.bus == rhs.bus)
  fieldCheck = fieldCheck && (lhs.hasEnabled == rhs.hasEnabled) && (!lhs.hasEnabled || lhs.enabled == rhs.enabled)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: AcceptanceFilterBypassCommand, rhs: AcceptanceFilterBypassCommand) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasBus == rhs.hasBus) && (!lhs.hasBus || lhs.bus == rhs.bus)
  fieldCheck = fieldCheck && (lhs.hasBypass == rhs.hasBypass) && (!lhs.hasBypass || lhs.bypass == rhs.bypass)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PayloadFormatCommand, rhs: PayloadFormatCommand) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasFormat == rhs.hasFormat) && (!lhs.hasFormat || lhs.format == rhs.format)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: PredefinedObd2RequestsCommand, rhs: PredefinedObd2RequestsCommand) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasEnabled == rhs.hasEnabled) && (!lhs.hasEnabled || lhs.enabled == rhs.enabled)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: NetworkOperatorSettings, rhs: NetworkOperatorSettings) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasAllowDataRoaming == rhs.hasAllowDataRoaming) && (!lhs.hasAllowDataRoaming || lhs.allowDataRoaming == rhs.allowDataRoaming)
  fieldCheck = fieldCheck && (lhs.hasOperatorSelectMode == rhs.hasOperatorSelectMode) && (!lhs.hasOperatorSelectMode || lhs.operatorSelectMode == rhs.operatorSelectMode)
  fieldCheck = fieldCheck && (lhs.hasNetworkDescriptor == rhs.hasNetworkDescriptor) && (!lhs.hasNetworkDescriptor || lhs.networkDescriptor == rhs.networkDescriptor)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: NetworkOperatorSettings.NetworkDescriptor, rhs: NetworkOperatorSettings.NetworkDescriptor) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasPlmn == rhs.hasPlmn) && (!lhs.hasPlmn || lhs.plmn == rhs.plmn)
  fieldCheck = fieldCheck && (lhs.hasNetworkType == rhs.hasNetworkType) && (!lhs.hasNetworkType || lhs.networkType == rhs.networkType)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: NetworkDataSettings, rhs: NetworkDataSettings) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasApn == rhs.hasApn) && (!lhs.hasApn || lhs.apn == rhs.apn)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ServerConnectSettings, rhs: ServerConnectSettings) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasHost == rhs.hasHost) && (!lhs.hasHost || lhs.host == rhs.host)
  fieldCheck = fieldCheck && (lhs.hasPort == rhs.hasPort) && (!lhs.hasPort || lhs.port == rhs.port)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ModemConfigurationCommand, rhs: ModemConfigurationCommand) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasNetworkOperatorSettings == rhs.hasNetworkOperatorSettings) && (!lhs.hasNetworkOperatorSettings || lhs.networkOperatorSettings == rhs.networkOperatorSettings)
  fieldCheck = fieldCheck && (lhs.hasNetworkDataSettings == rhs.hasNetworkDataSettings) && (!lhs.hasNetworkDataSettings || lhs.networkDataSettings == rhs.networkDataSettings)
  fieldCheck = fieldCheck && (lhs.hasServerConnectSettings == rhs.hasServerConnectSettings) && (!lhs.hasServerConnectSettings || lhs.serverConnectSettings == rhs.serverConnectSettings)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RtcconfigurationCommand, rhs: RtcconfigurationCommand) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasUnixTime == rhs.hasUnixTime) && (!lhs.hasUnixTime || lhs.unixTime == rhs.unixTime)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: CommandResponse, rhs: CommandResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
  fieldCheck = fieldCheck && (lhs.hasMessage == rhs.hasMessage) && (!lhs.hasMessage || lhs.message == rhs.message)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: DiagnosticRequest, rhs: DiagnosticRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasBus == rhs.hasBus) && (!lhs.hasBus || lhs.bus == rhs.bus)
  fieldCheck = fieldCheck && (lhs.hasMessageId == rhs.hasMessageId) && (!lhs.hasMessageId || lhs.messageId == rhs.messageId)
  fieldCheck = fieldCheck && (lhs.hasMode == rhs.hasMode) && (!lhs.hasMode || lhs.mode == rhs.mode)
  fieldCheck = fieldCheck && (lhs.hasPid == rhs.hasPid) && (!lhs.hasPid || lhs.pid == rhs.pid)
  fieldCheck = fieldCheck && (lhs.hasPayload == rhs.hasPayload) && (!lhs.hasPayload || lhs.payload == rhs.payload)
  fieldCheck = fieldCheck && (lhs.hasMultipleResponses == rhs.hasMultipleResponses) && (!lhs.hasMultipleResponses || lhs.multipleResponses == rhs.multipleResponses)
  fieldCheck = fieldCheck && (lhs.hasFrequency == rhs.hasFrequency) && (!lhs.hasFrequency || lhs.frequency == rhs.frequency)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasDecodedType == rhs.hasDecodedType) && (!lhs.hasDecodedType || lhs.decodedType == rhs.decodedType)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: DiagnosticResponse, rhs: DiagnosticResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasBus == rhs.hasBus) && (!lhs.hasBus || lhs.bus == rhs.bus)
  fieldCheck = fieldCheck && (lhs.hasMessageId == rhs.hasMessageId) && (!lhs.hasMessageId || lhs.messageId == rhs.messageId)
  fieldCheck = fieldCheck && (lhs.hasMode == rhs.hasMode) && (!lhs.hasMode || lhs.mode == rhs.mode)
  fieldCheck = fieldCheck && (lhs.hasPid == rhs.hasPid) && (!lhs.hasPid || lhs.pid == rhs.pid)
  fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
  fieldCheck = fieldCheck && (lhs.hasNegativeResponseCode == rhs.hasNegativeResponseCode) && (!lhs.hasNegativeResponseCode || lhs.negativeResponseCode == rhs.negativeResponseCode)
  fieldCheck = fieldCheck && (lhs.hasPayload == rhs.hasPayload) && (!lhs.hasPayload || lhs.payload == rhs.payload)
  fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: DynamicField, rhs: DynamicField) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
  fieldCheck = fieldCheck && (lhs.hasStringValue == rhs.hasStringValue) && (!lhs.hasStringValue || lhs.stringValue == rhs.stringValue)
  fieldCheck = fieldCheck && (lhs.hasNumericValue == rhs.hasNumericValue) && (!lhs.hasNumericValue || lhs.numericValue == rhs.numericValue)
  fieldCheck = fieldCheck && (lhs.hasBooleanValue == rhs.hasBooleanValue) && (!lhs.hasBooleanValue || lhs.booleanValue == rhs.booleanValue)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: SimpleMessage, rhs: SimpleMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
  fieldCheck = fieldCheck && (lhs.hasEvent == rhs.hasEvent) && (!lhs.hasEvent || lhs.event == rhs.event)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public struct OpenxcRoot {
  public static var sharedInstance : OpenxcRoot {
   struct Static {
       static let instance : OpenxcRoot = OpenxcRoot()
   }
   return Static.instance
  }
  public var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(registry: extensionRegistry)
  }
  public func registerAllExtensions(registry:ExtensionRegistry) {
  }
}

final public class VehicleMessage : GeneratedMessage {


    //Enum type declaration start 

    public enum Types:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case can = 1
      case simple = 2
      case diagnostic = 3
      case controlCommand = 4
      case commandResponse = 5

        //vkanishk
        public func toString() -> String {
            switch self {
            case .can: return "CAN"
            case .simple: return "SIMPLE"
            case .diagnostic: return "DIAGNOSTIC"
            case .controlCommand: return "CONTROL_COMMAND"
            case .commandResponse: return "COMMAND_RESPONSE"
            }
        }
        //vkanishk
        
      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
        switch self {
        case .can: return ".can"
        case .simple: return ".simple"
        case .diagnostic: return ".diagnostic"
        case .controlCommand: return ".controlCommand"
        case .commandResponse: return ".commandResponse"
        }
      }
    }

    //Enum type declaration end 
    public fileprivate(set) var type:VehicleMessage.Types = .can
    //  public fileprivate(set) var type:VehicleMessage.`Type` = VehicleMessage.`Type`.can
    
  public fileprivate(set) var hasType:Bool = false
  public fileprivate(set) var canMessage:CanMessage!
  public fileprivate(set) var hasCanMessage:Bool = false
  public fileprivate(set) var simpleMessage:SimpleMessage!
  public fileprivate(set) var hasSimpleMessage:Bool = false
  public fileprivate(set) var diagnosticResponse:DiagnosticResponse!
  public fileprivate(set) var hasDiagnosticResponse:Bool = false
  public fileprivate(set) var controlCommand:ControlCommand!
  public fileprivate(set) var hasControlCommand:Bool = false
  public fileprivate(set) var commandResponse:CommandResponse!
  public fileprivate(set) var hasCommandResponse:Bool = false
  public fileprivate(set) var timestamp:UInt64 = UInt64(0)

  public fileprivate(set) var hasTimestamp:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream:CodedOutputStream) throws {
    if hasType {
      try codedOutputStream.writeEnum(fieldNumber:1, value:type.rawValue)
    }
    if hasCanMessage {
      try codedOutputStream.writeMessage(fieldNumber:2, value:canMessage)
    }
    if hasSimpleMessage {
      try codedOutputStream.writeMessage(fieldNumber:3, value:simpleMessage)
    }
    if hasDiagnosticResponse {
      try codedOutputStream.writeMessage(fieldNumber:4, value:diagnosticResponse)
    }
    if hasControlCommand {
      try codedOutputStream.writeMessage(fieldNumber:5, value:controlCommand)
    }
    if hasCommandResponse {
      try codedOutputStream.writeMessage(fieldNumber:6, value:commandResponse)
    }
    if hasTimestamp {
      try codedOutputStream.writeUInt64(fieldNumber:7, value:timestamp)
    }
    try unknownFields.writeTo(codedOutputStream:codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasType) {
      serialize_size += type.rawValue.computeEnumSize(fieldNumber: 1)
    }
    if hasCanMessage {
        if let varSizecanMessage = canMessage?.computeMessageSize(fieldNumber: 2) {
            serialize_size += varSizecanMessage
        }
    }
    if hasSimpleMessage {
        if let varSizesimpleMessage = simpleMessage?.computeMessageSize(fieldNumber: 3) {
            serialize_size += varSizesimpleMessage
        }
    }
    if hasDiagnosticResponse {
        if let varSizediagnosticResponse = diagnosticResponse?.computeMessageSize(fieldNumber: 4) {
            serialize_size += varSizediagnosticResponse
        }
    }
    if hasControlCommand {
        if let varSizecontrolCommand = controlCommand?.computeMessageSize(fieldNumber: 5) {
            serialize_size += varSizecontrolCommand
        }
    }
    if hasCommandResponse {
        if let varSizecommandResponse = commandResponse?.computeMessageSize(fieldNumber: 6) {
            serialize_size += varSizecommandResponse
        }
    }
    if hasTimestamp {
      serialize_size += timestamp.computeUInt64Size(fieldNumber: 7)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> VehicleMessage.Builder {
    return VehicleMessage.classBuilder() as! VehicleMessage.Builder
  }
  public func getBuilder() -> VehicleMessage.Builder {
    return classBuilder() as! VehicleMessage.Builder
  }
  public override class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return VehicleMessage.Builder()
  }
  public override func classBuilder() -> ProtocolBuffersMessageBuilder {
    return VehicleMessage.Builder()
  }
  public func toBuilder() throws -> VehicleMessage.Builder {
    return try VehicleMessage.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:VehicleMessage) throws -> VehicleMessage.Builder {
    return try VehicleMessage.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if (hasType) {
      output += "\(indent) type: \(type.description)\n"
    }
    if hasCanMessage {
      output += "\(indent) canMessage {\n"
      if let outDescCanMessage = canMessage {
        output += try outDescCanMessage.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasSimpleMessage {
      output += "\(indent) simpleMessage {\n"
      if let outDescSimpleMessage = simpleMessage {
        output += try outDescSimpleMessage.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasDiagnosticResponse {
      output += "\(indent) diagnosticResponse {\n"
      if let outDescDiagnosticResponse = diagnosticResponse {
        output += try outDescDiagnosticResponse.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasControlCommand {
      output += "\(indent) controlCommand {\n"
      if let outDescControlCommand = controlCommand {
        output += try outDescControlCommand.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasCommandResponse {
      output += "\(indent) commandResponse {\n"
      if let outDescCommandResponse = commandResponse {
        output += try outDescCommandResponse.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasTimestamp {
      output += "\(indent) timestamp: \(timestamp) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasType {
             hashCode = (hashCode &* 31) &+ Int(type.rawValue)
          }
          if hasCanMessage {
              if let hashValuecanMessage = canMessage?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuecanMessage
              }
          }
          if hasSimpleMessage {
              if let hashValuesimpleMessage = simpleMessage?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuesimpleMessage
              }
          }
          if hasDiagnosticResponse {
              if let hashValuediagnosticResponse = diagnosticResponse?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuediagnosticResponse
              }
          }
          if hasControlCommand {
              if let hashValuecontrolCommand = controlCommand?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuecontrolCommand
              }
          }
          if hasCommandResponse {
              if let hashValuecommandResponse = commandResponse?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuecommandResponse
              }
          }
          if hasTimestamp {
             hashCode = (hashCode &* 31) &+ timestamp.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "VehicleMessage"
  }
  override public func className() -> String {
      return "VehicleMessage"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:VehicleMessage = VehicleMessage()
    public func getMessage() -> VehicleMessage {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasType:Bool{
          get {
              return builderResult.hasType
          }
      }
      public var type:VehicleMessage.Types {
          get {
              return builderResult.type
          }
          set (value) {
              builderResult.hasType = true
              builderResult.type = value
          }
      }
      public func setType(_ value:VehicleMessage.Types) -> VehicleMessage.Builder {
        self.type = value
        return self
      }
      public func clearType() -> VehicleMessage.Builder {
         builderResult.hasType = false
         builderResult.type = .can
         return self
      }
    public var hasCanMessage:Bool {
         get {
             return builderResult.hasCanMessage
         }
    }
    public var canMessage:CanMessage! {
         get {
             if canMessageBuilder_ != nil {
                builderResult.canMessage = canMessageBuilder_.getMessage()
             }
             return builderResult.canMessage
         }
         set (value) {
             builderResult.hasCanMessage = true
             builderResult.canMessage = value
         }
    }
    private var canMessageBuilder_:CanMessage.Builder! {
         didSet {
            builderResult.hasCanMessage = true
         }
    }
    public func getCanMessageBuilder() -> CanMessage.Builder {
      if canMessageBuilder_ == nil {
         canMessageBuilder_ = CanMessage.Builder()
         builderResult.canMessage = canMessageBuilder_.getMessage()
         if canMessage != nil {
            _ = try! canMessageBuilder_.mergeFrom(other: canMessage)
         }
      }
      return canMessageBuilder_
    }
    public func setCanMessage(_ value:CanMessage!) -> VehicleMessage.Builder {
      self.canMessage = value
      return self
    }
    public func mergeCanMessage(value:CanMessage) throws -> VehicleMessage.Builder {
      if builderResult.hasCanMessage {
        builderResult.canMessage = try CanMessage.builderWithPrototype(prototype: builderResult.canMessage).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.canMessage = value
      }
      builderResult.hasCanMessage = true
      return self
    }
    public func clearCanMessage() -> VehicleMessage.Builder {
      canMessageBuilder_ = nil
      builderResult.hasCanMessage = false
      builderResult.canMessage = nil
      return self
    }
    public var hasSimpleMessage:Bool {
         get {
             return builderResult.hasSimpleMessage
         }
    }
    public var simpleMessage:SimpleMessage! {
         get {
             if simpleMessageBuilder_ != nil {
                builderResult.simpleMessage = simpleMessageBuilder_.getMessage()
             }
             return builderResult.simpleMessage
         }
         set (value) {
             builderResult.hasSimpleMessage = true
             builderResult.simpleMessage = value
         }
    }
    private var simpleMessageBuilder_:SimpleMessage.Builder! {
         didSet {
            builderResult.hasSimpleMessage = true
         }
    }
    public func getSimpleMessageBuilder() -> SimpleMessage.Builder {
      if simpleMessageBuilder_ == nil {
         simpleMessageBuilder_ = SimpleMessage.Builder()
         builderResult.simpleMessage = simpleMessageBuilder_.getMessage()
         if simpleMessage != nil {
            _ = try! simpleMessageBuilder_.mergeFrom(other: simpleMessage)
         }
      }
      return simpleMessageBuilder_
    }
    public func setSimpleMessage(_ value:SimpleMessage!) -> VehicleMessage.Builder {
      self.simpleMessage = value
      return self
    }
    public func mergeSimpleMessage(value:SimpleMessage) throws -> VehicleMessage.Builder {
      if builderResult.hasSimpleMessage {
        builderResult.simpleMessage = try SimpleMessage.builderWithPrototype(prototype: builderResult.simpleMessage).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.simpleMessage = value
      }
      builderResult.hasSimpleMessage = true
      return self
    }
    public func clearSimpleMessage() -> VehicleMessage.Builder {
      simpleMessageBuilder_ = nil
      builderResult.hasSimpleMessage = false
      builderResult.simpleMessage = nil
      return self
    }
    public var hasDiagnosticResponse:Bool {
         get {
             return builderResult.hasDiagnosticResponse
         }
    }
    public var diagnosticResponse:DiagnosticResponse! {
         get {
             if diagnosticResponseBuilder_ != nil {
                builderResult.diagnosticResponse = diagnosticResponseBuilder_.getMessage()
             }
             return builderResult.diagnosticResponse
         }
         set (value) {
             builderResult.hasDiagnosticResponse = true
             builderResult.diagnosticResponse = value
         }
    }
    private var diagnosticResponseBuilder_:DiagnosticResponse.Builder! {
         didSet {
            builderResult.hasDiagnosticResponse = true
         }
    }
    public func getDiagnosticResponseBuilder() -> DiagnosticResponse.Builder {
      if diagnosticResponseBuilder_ == nil {
         diagnosticResponseBuilder_ = DiagnosticResponse.Builder()
         builderResult.diagnosticResponse = diagnosticResponseBuilder_.getMessage()
         if diagnosticResponse != nil {
            _ = try! diagnosticResponseBuilder_.mergeFrom(other: diagnosticResponse)
         }
      }
      return diagnosticResponseBuilder_
    }
    public func setDiagnosticResponse(_ value:DiagnosticResponse!) -> VehicleMessage.Builder {
      self.diagnosticResponse = value
      return self
    }
    public func mergeDiagnosticResponse(value:DiagnosticResponse) throws -> VehicleMessage.Builder {
      if builderResult.hasDiagnosticResponse {
        builderResult.diagnosticResponse = try DiagnosticResponse.builderWithPrototype(prototype: builderResult.diagnosticResponse).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.diagnosticResponse = value
      }
      builderResult.hasDiagnosticResponse = true
      return self
    }
    public func clearDiagnosticResponse() -> VehicleMessage.Builder {
      diagnosticResponseBuilder_ = nil
      builderResult.hasDiagnosticResponse = false
      builderResult.diagnosticResponse = nil
      return self
    }
    public var hasControlCommand:Bool {
         get {
             return builderResult.hasControlCommand
         }
    }
    public var controlCommand:ControlCommand! {
         get {
             if controlCommandBuilder_ != nil {
                builderResult.controlCommand = controlCommandBuilder_.getMessage()
             }
             return builderResult.controlCommand
         }
         set (value) {
             builderResult.hasControlCommand = true
             builderResult.controlCommand = value
         }
    }
    private var controlCommandBuilder_:ControlCommand.Builder! {
         didSet {
            builderResult.hasControlCommand = true
         }
    }
    public func getControlCommandBuilder() -> ControlCommand.Builder {
      if controlCommandBuilder_ == nil {
         controlCommandBuilder_ = ControlCommand.Builder()
         builderResult.controlCommand = controlCommandBuilder_.getMessage()
         if controlCommand != nil {
            _ = try! controlCommandBuilder_.mergeFrom(other: controlCommand)
         }
      }
      return controlCommandBuilder_
    }
    public func setControlCommand(_ value:ControlCommand!) -> VehicleMessage.Builder {
      self.controlCommand = value
      return self
    }
    public func mergeControlCommand(value:ControlCommand) throws -> VehicleMessage.Builder {
      if builderResult.hasControlCommand {
        builderResult.controlCommand = try ControlCommand.builderWithPrototype(prototype: builderResult.controlCommand).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.controlCommand = value
      }
      builderResult.hasControlCommand = true
      return self
    }
    public func clearControlCommand() -> VehicleMessage.Builder {
      controlCommandBuilder_ = nil
      builderResult.hasControlCommand = false
      builderResult.controlCommand = nil
      return self
    }
    public var hasCommandResponse:Bool {
         get {
             return builderResult.hasCommandResponse
         }
    }
    public var commandResponse:CommandResponse! {
         get {
             if commandResponseBuilder_ != nil {
                builderResult.commandResponse = commandResponseBuilder_.getMessage()
             }
             return builderResult.commandResponse
         }
         set (value) {
             builderResult.hasCommandResponse = true
             builderResult.commandResponse = value
         }
    }
    private var commandResponseBuilder_:CommandResponse.Builder! {
         didSet {
            builderResult.hasCommandResponse = true
         }
    }
    public func getCommandResponseBuilder() -> CommandResponse.Builder {
      if commandResponseBuilder_ == nil {
         commandResponseBuilder_ = CommandResponse.Builder()
         builderResult.commandResponse = commandResponseBuilder_.getMessage()
         if commandResponse != nil {
            _ = try! commandResponseBuilder_.mergeFrom(other: commandResponse)
         }
      }
      return commandResponseBuilder_
    }
    public func setCommandResponse(_ value:CommandResponse!) -> VehicleMessage.Builder {
      self.commandResponse = value
      return self
    }
    public func mergeCommandResponse(value:CommandResponse) throws -> VehicleMessage.Builder {
      if builderResult.hasCommandResponse {
        builderResult.commandResponse = try CommandResponse.builderWithPrototype(prototype: builderResult.commandResponse).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.commandResponse = value
      }
      builderResult.hasCommandResponse = true
      return self
    }
    public func clearCommandResponse() -> VehicleMessage.Builder {
      commandResponseBuilder_ = nil
      builderResult.hasCommandResponse = false
      builderResult.commandResponse = nil
      return self
    }
    public var hasTimestamp:Bool {
         get {
              return builderResult.hasTimestamp
         }
    }
    public var timestamp:UInt64 {
         get {
              return builderResult.timestamp
         }
         set (value) {
             builderResult.hasTimestamp = true
             builderResult.timestamp = value
         }
    }
    public func setTimestamp(_ value:UInt64) -> VehicleMessage.Builder {
      self.timestamp = value
      return self
    }
    public func clearTimestamp() -> VehicleMessage.Builder{
         builderResult.hasTimestamp = false
         builderResult.timestamp = UInt64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> VehicleMessage.Builder {
      builderResult = VehicleMessage()
      return self
    }
    public override func clone() throws -> VehicleMessage.Builder {
      return try VehicleMessage.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> VehicleMessage {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> VehicleMessage {
      let returnMe:VehicleMessage = builderResult
      return returnMe
    }
    public func mergeFrom(other:VehicleMessage) throws -> VehicleMessage.Builder {
      if other == VehicleMessage() {
       return self
      }
      if other.hasType {
           type = other.type
      }
      if other.hasCanMessage {
          _ = try mergeCanMessage(value: other.canMessage)
      }
      if other.hasSimpleMessage {
          _ = try mergeSimpleMessage(value: other.simpleMessage)
      }
      if other.hasDiagnosticResponse {
          _ = try mergeDiagnosticResponse(value: other.diagnosticResponse)
      }
      if other.hasControlCommand {
          _ = try mergeControlCommand(value: other.controlCommand)
      }
      if other.hasCommandResponse {
          _ = try mergeCommandResponse(value: other.commandResponse)
      }
      if other.hasTimestamp {
           timestamp = other.timestamp
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFrom(codedInputStream:CodedInputStream) throws -> VehicleMessage.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VehicleMessage.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueInttype = try codedInputStream.readEnum()
          //if let enumstype = VehicleMessage.`Type`(rawValue:valueInttype){
          if let enumstype = VehicleMessage.Types.init(rawValue: valueInttype) {
               type = enumstype
          } else {
            _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value: Int64(valueInttype))
            
          }

        case 18:
          let subBuilder:CanMessage.Builder = CanMessage.Builder()
          if hasCanMessage {
           _ = try subBuilder.mergeFrom(other: canMessage)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          canMessage = subBuilder.buildPartial()

        case 26:
          let subBuilder:SimpleMessage.Builder = SimpleMessage.Builder()
          if hasSimpleMessage {
           _ = try subBuilder.mergeFrom(other: simpleMessage)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          simpleMessage = subBuilder.buildPartial()

        case 34:
          let subBuilder:DiagnosticResponse.Builder = DiagnosticResponse.Builder()
          if hasDiagnosticResponse {
           _ = try subBuilder.mergeFrom(other: diagnosticResponse)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          diagnosticResponse = subBuilder.buildPartial()

        case 42:
          let subBuilder:ControlCommand.Builder = ControlCommand.Builder()
          if hasControlCommand {
           _ = try subBuilder.mergeFrom(other: controlCommand)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          controlCommand = subBuilder.buildPartial()

        case 50:
          let subBuilder:CommandResponse.Builder = CommandResponse.Builder()
          if hasCommandResponse {
           _ = try subBuilder.mergeFrom(other: commandResponse)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          commandResponse = subBuilder.buildPartial()

        case 56:
          timestamp = try codedInputStream.readUInt64()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class CanMessage : GeneratedMessage {


    //Enum type declaration start 

    public enum FrameFormat:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case standard = 1
      case extended = 2

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
        switch self {
        case .standard: return ".standard"
        case .extended: return ".extended"
        }
      }
    }

    //Enum type declaration end 

  public fileprivate(set) var bus:Int32 = Int32(0)

  public fileprivate(set) var hasBus:Bool = false
  public fileprivate(set) var id:UInt32 = UInt32(0)

  public fileprivate(set) var hasId:Bool = false
  public fileprivate(set) var data:Data = Data()

  public fileprivate(set) var hasData:Bool = false
  public fileprivate(set) var frameFormat:CanMessage.FrameFormat = CanMessage.FrameFormat.standard
  public fileprivate(set) var hasFrameFormat:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream:CodedOutputStream) throws {
    if hasBus {
      try codedOutputStream.writeInt32(fieldNumber:1, value:bus)
    }
    if hasId {
      try codedOutputStream.writeUInt32(fieldNumber:2, value:id)
    }
    if hasData {
      try codedOutputStream.writeData(fieldNumber:3, value:data)
    }
    if hasFrameFormat {
      try codedOutputStream.writeEnum(fieldNumber:4, value:frameFormat.rawValue)
    }
    try unknownFields.writeTo(codedOutputStream:codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasBus {
      serialize_size += bus.computeInt32Size(fieldNumber: 1)
    }
    if hasId {
      serialize_size += id.computeUInt32Size(fieldNumber: 2)
    }
    if hasData {
      serialize_size += data.computeDataSize(fieldNumber: 3)
    }
    if (hasFrameFormat) {
      serialize_size += frameFormat.rawValue.computeEnumSize(fieldNumber: 4)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> CanMessage.Builder {
    return CanMessage.classBuilder() as! CanMessage.Builder
  }
  public func getBuilder() -> CanMessage.Builder {
    return classBuilder() as! CanMessage.Builder
  }
  public override class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return CanMessage.Builder()
  }
  public override func classBuilder() -> ProtocolBuffersMessageBuilder {
    return CanMessage.Builder()
  }
  public func toBuilder() throws -> CanMessage.Builder {
    return try CanMessage.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:CanMessage) throws -> CanMessage.Builder {
    return try CanMessage.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasBus {
      output += "\(indent) bus: \(bus) \n"
    }
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasData {
      output += "\(indent) data: \(data) \n"
    }
    if (hasFrameFormat) {
      output += "\(indent) frameFormat: \(frameFormat.description)\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasBus {
             hashCode = (hashCode &* 31) &+ bus.hashValue
          }
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasData {
             hashCode = (hashCode &* 31) &+ data.hashValue
          }
          if hasFrameFormat {
             hashCode = (hashCode &* 31) &+ Int(frameFormat.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "CanMessage"
  }
  override public func className() -> String {
      return "CanMessage"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:CanMessage = CanMessage()
    public func getMessage() -> CanMessage {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasBus:Bool {
         get {
              return builderResult.hasBus
         }
    }
    public var bus:Int32 {
         get {
              return builderResult.bus
         }
         set (value) {
             builderResult.hasBus = true
             builderResult.bus = value
         }
    }
    public func setBus(_ value:Int32) -> CanMessage.Builder {
      self.bus = value
      return self
    }
    public func clearBus() -> CanMessage.Builder{
         builderResult.hasBus = false
         builderResult.bus = Int32(0)
         return self
    }
    public var hasId:Bool {
         get {
              return builderResult.hasId
         }
    }
    public var id:UInt32 {
         get {
              return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    public func setId(_ value:UInt32) -> CanMessage.Builder {
      self.id = value
      return self
    }
    public func clearId() -> CanMessage.Builder{
         builderResult.hasId = false
         builderResult.id = UInt32(0)
         return self
    }
    public var hasData:Bool {
         get {
              return builderResult.hasData
         }
    }
    public var data:Data {
         get {
              return builderResult.data
         }
         set (value) {
             builderResult.hasData = true
             builderResult.data = value
         }
    }
    public func setData(_ value:Data) -> CanMessage.Builder {
      self.data = value
      return self
    }
    public func clearData() -> CanMessage.Builder{
         builderResult.hasData = false
         builderResult.data = Data()
         return self
    }
      public var hasFrameFormat:Bool{
          get {
              return builderResult.hasFrameFormat
          }
      }
      public var frameFormat:CanMessage.FrameFormat {
          get {
              return builderResult.frameFormat
          }
          set (value) {
              builderResult.hasFrameFormat = true
              builderResult.frameFormat = value
          }
      }
      public func setFrameFormat(_ value:CanMessage.FrameFormat) -> CanMessage.Builder {
        self.frameFormat = value
        return self
      }
      public func clearFrameFormat() -> CanMessage.Builder {
         builderResult.hasFrameFormat = false
         builderResult.frameFormat = .standard
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> CanMessage.Builder {
      builderResult = CanMessage()
      return self
    }
    public override func clone() throws -> CanMessage.Builder {
      return try CanMessage.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> CanMessage {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> CanMessage {
      let returnMe:CanMessage = builderResult
      return returnMe
    }
    public func mergeFrom(other:CanMessage) throws -> CanMessage.Builder {
      if other == CanMessage() {
       return self
      }
      if other.hasBus {
           bus = other.bus
      }
      if other.hasId {
           id = other.id
      }
      if other.hasData {
           data = other.data
      }
      if other.hasFrameFormat {
           frameFormat = other.frameFormat
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFrom(codedInputStream:CodedInputStream) throws -> CanMessage.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CanMessage.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          bus = try codedInputStream.readInt32()

        case 16:
          id = try codedInputStream.readUInt32()

        case 26:
          data = try codedInputStream.readData()

        case 32:
          let valueIntframeFormat = try codedInputStream.readEnum()
          if let enumsframeFormat = CanMessage.FrameFormat(rawValue:valueIntframeFormat){
               frameFormat = enumsframeFormat
          } else {
            _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 4, value:Int64(valueIntframeFormat))
          }

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ControlCommand : GeneratedMessage {


    //Enum type declaration start 

    public enum Types:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case version = 1
      case deviceId = 2
      case diagnostic = 3
      case passthrough = 4
      case acceptanceFilterBypass = 5
      case payloadFormat = 6
      case predefinedObd2Requests = 7
      case modemConfiguration = 8
      case rtcConfiguration = 9
      case sdMountStatus = 10
      case platform = 11

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
        switch self {
        case .version: return ".version"
        case .deviceId: return ".deviceId"
        case .diagnostic: return ".diagnostic"
        case .passthrough: return ".passthrough"
        case .acceptanceFilterBypass: return ".acceptanceFilterBypass"
        case .payloadFormat: return ".payloadFormat"
        case .predefinedObd2Requests: return ".predefinedObd2Requests"
        case .modemConfiguration: return ".modemConfiguration"
        case .rtcConfiguration: return ".rtcConfiguration"
        case .sdMountStatus: return ".sdMountStatus"
        case .platform: return ".platform"
        }
      }
    }

    //Enum type declaration end 

  public fileprivate(set) var type:ControlCommand.Types = .version
  public fileprivate(set) var hasType:Bool = false
  public fileprivate(set) var diagnosticRequest:DiagnosticControlCommand!
  public fileprivate(set) var hasDiagnosticRequest:Bool = false
  public fileprivate(set) var passthroughModeRequest:PassthroughModeControlCommand!
  public fileprivate(set) var hasPassthroughModeRequest:Bool = false
  public fileprivate(set) var acceptanceFilterBypassCommand:AcceptanceFilterBypassCommand!
  public fileprivate(set) var hasAcceptanceFilterBypassCommand:Bool = false
  public fileprivate(set) var payloadFormatCommand:PayloadFormatCommand!
  public fileprivate(set) var hasPayloadFormatCommand:Bool = false
  public fileprivate(set) var predefinedObd2RequestsCommand:PredefinedObd2RequestsCommand!
  public fileprivate(set) var hasPredefinedObd2RequestsCommand:Bool = false
  public fileprivate(set) var modemConfigurationCommand:ModemConfigurationCommand!
  public fileprivate(set) var hasModemConfigurationCommand:Bool = false
  public fileprivate(set) var rtcConfigurationCommand:RtcconfigurationCommand!
  public fileprivate(set) var hasRtcConfigurationCommand:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream:CodedOutputStream) throws {
    if hasType {
      try codedOutputStream.writeEnum(fieldNumber:1, value:type.rawValue)
    }
    if hasDiagnosticRequest {
      try codedOutputStream.writeMessage(fieldNumber:2, value:diagnosticRequest)
    }
    if hasPassthroughModeRequest {
      try codedOutputStream.writeMessage(fieldNumber:3, value:passthroughModeRequest)
    }
    if hasAcceptanceFilterBypassCommand {
      try codedOutputStream.writeMessage(fieldNumber:4, value:acceptanceFilterBypassCommand)
    }
    if hasPayloadFormatCommand {
      try codedOutputStream.writeMessage(fieldNumber:5, value:payloadFormatCommand)
    }
    if hasPredefinedObd2RequestsCommand {
      try codedOutputStream.writeMessage(fieldNumber:6, value:predefinedObd2RequestsCommand)
    }
    if hasModemConfigurationCommand {
      try codedOutputStream.writeMessage(fieldNumber:7, value:modemConfigurationCommand)
    }
    if hasRtcConfigurationCommand {
      try codedOutputStream.writeMessage(fieldNumber:8, value:rtcConfigurationCommand)
    }
    try unknownFields.writeTo(codedOutputStream:codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasType) {
      serialize_size += type.rawValue.computeEnumSize(fieldNumber: 1)
    }
    if hasDiagnosticRequest {
        if let varSizediagnosticRequest = diagnosticRequest?.computeMessageSize(fieldNumber: 2) {
            serialize_size += varSizediagnosticRequest
        }
    }
    if hasPassthroughModeRequest {
        if let varSizepassthroughModeRequest = passthroughModeRequest?.computeMessageSize(fieldNumber: 3) {
            serialize_size += varSizepassthroughModeRequest
        }
    }
    if hasAcceptanceFilterBypassCommand {
        if let varSizeacceptanceFilterBypassCommand = acceptanceFilterBypassCommand?.computeMessageSize(fieldNumber: 4) {
            serialize_size += varSizeacceptanceFilterBypassCommand
        }
    }
    if hasPayloadFormatCommand {
        if let varSizepayloadFormatCommand = payloadFormatCommand?.computeMessageSize(fieldNumber: 5) {
            serialize_size += varSizepayloadFormatCommand
        }
    }
    if hasPredefinedObd2RequestsCommand {
        if let varSizepredefinedObd2RequestsCommand = predefinedObd2RequestsCommand?.computeMessageSize(fieldNumber: 6) {
            serialize_size += varSizepredefinedObd2RequestsCommand
        }
    }
    if hasModemConfigurationCommand {
        if let varSizemodemConfigurationCommand = modemConfigurationCommand?.computeMessageSize(fieldNumber: 7) {
            serialize_size += varSizemodemConfigurationCommand
        }
    }
    if hasRtcConfigurationCommand {
        if let varSizertcConfigurationCommand = rtcConfigurationCommand?.computeMessageSize(fieldNumber: 8) {
            serialize_size += varSizertcConfigurationCommand
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> ControlCommand.Builder {
    return ControlCommand.classBuilder() as! ControlCommand.Builder
  }
  public func getBuilder() -> ControlCommand.Builder {
    return classBuilder() as! ControlCommand.Builder
  }
  public override class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return ControlCommand.Builder()
  }
  public override func classBuilder() -> ProtocolBuffersMessageBuilder {
    return ControlCommand.Builder()
  }
  public func toBuilder() throws -> ControlCommand.Builder {
    return try ControlCommand.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:ControlCommand) throws -> ControlCommand.Builder {
    return try ControlCommand.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if (hasType) {
      output += "\(indent) type: \(type.description)\n"
    }
    if hasDiagnosticRequest {
      output += "\(indent) diagnosticRequest {\n"
      if let outDescDiagnosticRequest = diagnosticRequest {
        output += try outDescDiagnosticRequest.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasPassthroughModeRequest {
      output += "\(indent) passthroughModeRequest {\n"
      if let outDescPassthroughModeRequest = passthroughModeRequest {
        output += try outDescPassthroughModeRequest.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasAcceptanceFilterBypassCommand {
      output += "\(indent) acceptanceFilterBypassCommand {\n"
      if let outDescAcceptanceFilterBypassCommand = acceptanceFilterBypassCommand {
        output += try outDescAcceptanceFilterBypassCommand.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasPayloadFormatCommand {
      output += "\(indent) payloadFormatCommand {\n"
      if let outDescPayloadFormatCommand = payloadFormatCommand {
        output += try outDescPayloadFormatCommand.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasPredefinedObd2RequestsCommand {
      output += "\(indent) predefinedObd2RequestsCommand {\n"
      if let outDescPredefinedObd2RequestsCommand = predefinedObd2RequestsCommand {
        output += try outDescPredefinedObd2RequestsCommand.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasModemConfigurationCommand {
      output += "\(indent) modemConfigurationCommand {\n"
      if let outDescModemConfigurationCommand = modemConfigurationCommand {
        output += try outDescModemConfigurationCommand.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasRtcConfigurationCommand {
      output += "\(indent) rtcConfigurationCommand {\n"
      if let outDescRtcConfigurationCommand = rtcConfigurationCommand {
        output += try outDescRtcConfigurationCommand.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasType {
             hashCode = (hashCode &* 31) &+ Int(type.rawValue)
          }
          if hasDiagnosticRequest {
              if let hashValuediagnosticRequest = diagnosticRequest?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuediagnosticRequest
              }
          }
          if hasPassthroughModeRequest {
              if let hashValuepassthroughModeRequest = passthroughModeRequest?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuepassthroughModeRequest
              }
          }
          if hasAcceptanceFilterBypassCommand {
              if let hashValueacceptanceFilterBypassCommand = acceptanceFilterBypassCommand?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueacceptanceFilterBypassCommand
              }
          }
          if hasPayloadFormatCommand {
              if let hashValuepayloadFormatCommand = payloadFormatCommand?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuepayloadFormatCommand
              }
          }
          if hasPredefinedObd2RequestsCommand {
              if let hashValuepredefinedObd2RequestsCommand = predefinedObd2RequestsCommand?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuepredefinedObd2RequestsCommand
              }
          }
          if hasModemConfigurationCommand {
              if let hashValuemodemConfigurationCommand = modemConfigurationCommand?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuemodemConfigurationCommand
              }
          }
          if hasRtcConfigurationCommand {
              if let hashValuertcConfigurationCommand = rtcConfigurationCommand?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuertcConfigurationCommand
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ControlCommand"
  }
  override public func className() -> String {
      return "ControlCommand"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ControlCommand = ControlCommand()
    public func getMessage() -> ControlCommand {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasType:Bool{
          get {
              return builderResult.hasType
          }
      }
      public var type:ControlCommand.Types {
          get {
              return builderResult.type
          }
          set (value) {
              builderResult.hasType = true
              builderResult.type = value
          }
      }
      public func setType(_ value:ControlCommand.Types) -> ControlCommand.Builder {
        self.type = value
        return self
      }
      public func clearType() -> ControlCommand.Builder {
         builderResult.hasType = false
         builderResult.type = .version
         return self
      }
    public var hasDiagnosticRequest:Bool {
         get {
             return builderResult.hasDiagnosticRequest
         }
    }
    public var diagnosticRequest:DiagnosticControlCommand! {
         get {
             if diagnosticRequestBuilder_ != nil {
                builderResult.diagnosticRequest = diagnosticRequestBuilder_.getMessage()
             }
             return builderResult.diagnosticRequest
         }
         set (value) {
             builderResult.hasDiagnosticRequest = true
             builderResult.diagnosticRequest = value
         }
    }
    private var diagnosticRequestBuilder_:DiagnosticControlCommand.Builder! {
         didSet {
            builderResult.hasDiagnosticRequest = true
         }
    }
    public func getDiagnosticRequestBuilder() -> DiagnosticControlCommand.Builder {
      if diagnosticRequestBuilder_ == nil {
         diagnosticRequestBuilder_ = DiagnosticControlCommand.Builder()
         builderResult.diagnosticRequest = diagnosticRequestBuilder_.getMessage()
         if diagnosticRequest != nil {
            _ = try! diagnosticRequestBuilder_.mergeFrom(other: diagnosticRequest)
         }
      }
      return diagnosticRequestBuilder_
    }
    public func setDiagnosticRequest(_ value:DiagnosticControlCommand!) -> ControlCommand.Builder {
      self.diagnosticRequest = value
      return self
    }
    public func mergeDiagnosticRequest(value:DiagnosticControlCommand) throws -> ControlCommand.Builder {
      if builderResult.hasDiagnosticRequest {
        builderResult.diagnosticRequest = try DiagnosticControlCommand.builderWithPrototype(prototype: builderResult.diagnosticRequest).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.diagnosticRequest = value
      }
      builderResult.hasDiagnosticRequest = true
      return self
    }
    public func clearDiagnosticRequest() -> ControlCommand.Builder {
      diagnosticRequestBuilder_ = nil
      builderResult.hasDiagnosticRequest = false
      builderResult.diagnosticRequest = nil
      return self
    }
    public var hasPassthroughModeRequest:Bool {
         get {
             return builderResult.hasPassthroughModeRequest
         }
    }
    public var passthroughModeRequest:PassthroughModeControlCommand! {
         get {
             if passthroughModeRequestBuilder_ != nil {
                builderResult.passthroughModeRequest = passthroughModeRequestBuilder_.getMessage()
             }
             return builderResult.passthroughModeRequest
         }
         set (value) {
             builderResult.hasPassthroughModeRequest = true
             builderResult.passthroughModeRequest = value
         }
    }
    private var passthroughModeRequestBuilder_:PassthroughModeControlCommand.Builder! {
         didSet {
            builderResult.hasPassthroughModeRequest = true
         }
    }
    public func getPassthroughModeRequestBuilder() -> PassthroughModeControlCommand.Builder {
      if passthroughModeRequestBuilder_ == nil {
         passthroughModeRequestBuilder_ = PassthroughModeControlCommand.Builder()
         builderResult.passthroughModeRequest = passthroughModeRequestBuilder_.getMessage()
         if passthroughModeRequest != nil {
            _ = try! passthroughModeRequestBuilder_.mergeFrom(other: passthroughModeRequest)
         }
      }
      return passthroughModeRequestBuilder_
    }
    public func setPassthroughModeRequest(_ value:PassthroughModeControlCommand!) -> ControlCommand.Builder {
      self.passthroughModeRequest = value
      return self
    }
    public func mergePassthroughModeRequest(value:PassthroughModeControlCommand) throws -> ControlCommand.Builder {
      if builderResult.hasPassthroughModeRequest {
        builderResult.passthroughModeRequest = try PassthroughModeControlCommand.builderWithPrototype(prototype: builderResult.passthroughModeRequest).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.passthroughModeRequest = value
      }
      builderResult.hasPassthroughModeRequest = true
      return self
    }
    public func clearPassthroughModeRequest() -> ControlCommand.Builder {
      passthroughModeRequestBuilder_ = nil
      builderResult.hasPassthroughModeRequest = false
      builderResult.passthroughModeRequest = nil
      return self
    }
    public var hasAcceptanceFilterBypassCommand:Bool {
         get {
             return builderResult.hasAcceptanceFilterBypassCommand
         }
    }
    public var acceptanceFilterBypassCommand:AcceptanceFilterBypassCommand! {
         get {
             if acceptanceFilterBypassCommandBuilder_ != nil {
                builderResult.acceptanceFilterBypassCommand = acceptanceFilterBypassCommandBuilder_.getMessage()
             }
             return builderResult.acceptanceFilterBypassCommand
         }
         set (value) {
             builderResult.hasAcceptanceFilterBypassCommand = true
             builderResult.acceptanceFilterBypassCommand = value
         }
    }
    private var acceptanceFilterBypassCommandBuilder_:AcceptanceFilterBypassCommand.Builder! {
         didSet {
            builderResult.hasAcceptanceFilterBypassCommand = true
         }
    }
    public func getAcceptanceFilterBypassCommandBuilder() -> AcceptanceFilterBypassCommand.Builder {
      if acceptanceFilterBypassCommandBuilder_ == nil {
         acceptanceFilterBypassCommandBuilder_ = AcceptanceFilterBypassCommand.Builder()
         builderResult.acceptanceFilterBypassCommand = acceptanceFilterBypassCommandBuilder_.getMessage()
         if acceptanceFilterBypassCommand != nil {
            _ = try! acceptanceFilterBypassCommandBuilder_.mergeFrom(other: acceptanceFilterBypassCommand)
         }
      }
      return acceptanceFilterBypassCommandBuilder_
    }
    public func setAcceptanceFilterBypassCommand(_ value:AcceptanceFilterBypassCommand!) -> ControlCommand.Builder {
      self.acceptanceFilterBypassCommand = value
      return self
    }
    public func mergeAcceptanceFilterBypassCommand(value:AcceptanceFilterBypassCommand) throws -> ControlCommand.Builder {
      if builderResult.hasAcceptanceFilterBypassCommand {
        builderResult.acceptanceFilterBypassCommand = try AcceptanceFilterBypassCommand.builderWithPrototype(prototype: builderResult.acceptanceFilterBypassCommand).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.acceptanceFilterBypassCommand = value
      }
      builderResult.hasAcceptanceFilterBypassCommand = true
      return self
    }
    public func clearAcceptanceFilterBypassCommand() -> ControlCommand.Builder {
      acceptanceFilterBypassCommandBuilder_ = nil
      builderResult.hasAcceptanceFilterBypassCommand = false
      builderResult.acceptanceFilterBypassCommand = nil
      return self
    }
    public var hasPayloadFormatCommand:Bool {
         get {
             return builderResult.hasPayloadFormatCommand
         }
    }
    public var payloadFormatCommand:PayloadFormatCommand! {
         get {
             if payloadFormatCommandBuilder_ != nil {
                builderResult.payloadFormatCommand = payloadFormatCommandBuilder_.getMessage()
             }
             return builderResult.payloadFormatCommand
         }
         set (value) {
             builderResult.hasPayloadFormatCommand = true
             builderResult.payloadFormatCommand = value
         }
    }
    private var payloadFormatCommandBuilder_:PayloadFormatCommand.Builder! {
         didSet {
            builderResult.hasPayloadFormatCommand = true
         }
    }
    public func getPayloadFormatCommandBuilder() -> PayloadFormatCommand.Builder {
      if payloadFormatCommandBuilder_ == nil {
         payloadFormatCommandBuilder_ = PayloadFormatCommand.Builder()
         builderResult.payloadFormatCommand = payloadFormatCommandBuilder_.getMessage()
         if payloadFormatCommand != nil {
            _ = try! payloadFormatCommandBuilder_.mergeFrom(other: payloadFormatCommand)
         }
      }
      return payloadFormatCommandBuilder_
    }
    public func setPayloadFormatCommand(_ value:PayloadFormatCommand!) -> ControlCommand.Builder {
      self.payloadFormatCommand = value
      return self
    }
    public func mergePayloadFormatCommand(value:PayloadFormatCommand) throws -> ControlCommand.Builder {
      if builderResult.hasPayloadFormatCommand {
        builderResult.payloadFormatCommand = try PayloadFormatCommand.builderWithPrototype(prototype: builderResult.payloadFormatCommand).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.payloadFormatCommand = value
      }
      builderResult.hasPayloadFormatCommand = true
      return self
    }
    public func clearPayloadFormatCommand() -> ControlCommand.Builder {
      payloadFormatCommandBuilder_ = nil
      builderResult.hasPayloadFormatCommand = false
      builderResult.payloadFormatCommand = nil
      return self
    }
    public var hasPredefinedObd2RequestsCommand:Bool {
         get {
             return builderResult.hasPredefinedObd2RequestsCommand
         }
    }
    public var predefinedObd2RequestsCommand:PredefinedObd2RequestsCommand! {
         get {
             if predefinedObd2RequestsCommandBuilder_ != nil {
                builderResult.predefinedObd2RequestsCommand = predefinedObd2RequestsCommandBuilder_.getMessage()
             }
             return builderResult.predefinedObd2RequestsCommand
         }
         set (value) {
             builderResult.hasPredefinedObd2RequestsCommand = true
             builderResult.predefinedObd2RequestsCommand = value
         }
    }
    private var predefinedObd2RequestsCommandBuilder_:PredefinedObd2RequestsCommand.Builder! {
         didSet {
            builderResult.hasPredefinedObd2RequestsCommand = true
         }
    }
    public func getPredefinedObd2RequestsCommandBuilder() -> PredefinedObd2RequestsCommand.Builder {
      if predefinedObd2RequestsCommandBuilder_ == nil {
         predefinedObd2RequestsCommandBuilder_ = PredefinedObd2RequestsCommand.Builder()
         builderResult.predefinedObd2RequestsCommand = predefinedObd2RequestsCommandBuilder_.getMessage()
         if predefinedObd2RequestsCommand != nil {
            _ = try! predefinedObd2RequestsCommandBuilder_.mergeFrom(other: predefinedObd2RequestsCommand)
         }
      }
      return predefinedObd2RequestsCommandBuilder_
    }
    public func setPredefinedObd2RequestsCommand(_ value:PredefinedObd2RequestsCommand!) -> ControlCommand.Builder {
      self.predefinedObd2RequestsCommand = value
      return self
    }
    public func mergePredefinedObd2RequestsCommand(value:PredefinedObd2RequestsCommand) throws -> ControlCommand.Builder {
      if builderResult.hasPredefinedObd2RequestsCommand {
        builderResult.predefinedObd2RequestsCommand = try PredefinedObd2RequestsCommand.builderWithPrototype(prototype: builderResult.predefinedObd2RequestsCommand).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.predefinedObd2RequestsCommand = value
      }
      builderResult.hasPredefinedObd2RequestsCommand = true
      return self
    }
    public func clearPredefinedObd2RequestsCommand() -> ControlCommand.Builder {
      predefinedObd2RequestsCommandBuilder_ = nil
      builderResult.hasPredefinedObd2RequestsCommand = false
      builderResult.predefinedObd2RequestsCommand = nil
      return self
    }
    public var hasModemConfigurationCommand:Bool {
         get {
             return builderResult.hasModemConfigurationCommand
         }
    }
    public var modemConfigurationCommand:ModemConfigurationCommand! {
         get {
             if modemConfigurationCommandBuilder_ != nil {
                builderResult.modemConfigurationCommand = modemConfigurationCommandBuilder_.getMessage()
             }
             return builderResult.modemConfigurationCommand
         }
         set (value) {
             builderResult.hasModemConfigurationCommand = true
             builderResult.modemConfigurationCommand = value
         }
    }
    private var modemConfigurationCommandBuilder_:ModemConfigurationCommand.Builder! {
         didSet {
            builderResult.hasModemConfigurationCommand = true
         }
    }
    public func getModemConfigurationCommandBuilder() -> ModemConfigurationCommand.Builder {
      if modemConfigurationCommandBuilder_ == nil {
         modemConfigurationCommandBuilder_ = ModemConfigurationCommand.Builder()
         builderResult.modemConfigurationCommand = modemConfigurationCommandBuilder_.getMessage()
         if modemConfigurationCommand != nil {
            _ = try! modemConfigurationCommandBuilder_.mergeFrom(other: modemConfigurationCommand)
         }
      }
      return modemConfigurationCommandBuilder_
    }
    public func setModemConfigurationCommand(_ value:ModemConfigurationCommand!) -> ControlCommand.Builder {
      self.modemConfigurationCommand = value
      return self
    }
    public func mergeModemConfigurationCommand(value:ModemConfigurationCommand) throws -> ControlCommand.Builder {
      if builderResult.hasModemConfigurationCommand {
        builderResult.modemConfigurationCommand = try ModemConfigurationCommand.builderWithPrototype(prototype: builderResult.modemConfigurationCommand).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.modemConfigurationCommand = value
      }
      builderResult.hasModemConfigurationCommand = true
      return self
    }
    public func clearModemConfigurationCommand() -> ControlCommand.Builder {
      modemConfigurationCommandBuilder_ = nil
      builderResult.hasModemConfigurationCommand = false
      builderResult.modemConfigurationCommand = nil
      return self
    }
    public var hasRtcConfigurationCommand:Bool {
         get {
             return builderResult.hasRtcConfigurationCommand
         }
    }
    public var rtcConfigurationCommand:RtcconfigurationCommand! {
         get {
             if rtcConfigurationCommandBuilder_ != nil {
                builderResult.rtcConfigurationCommand = rtcConfigurationCommandBuilder_.getMessage()
             }
             return builderResult.rtcConfigurationCommand
         }
         set (value) {
             builderResult.hasRtcConfigurationCommand = true
             builderResult.rtcConfigurationCommand = value
         }
    }
    private var rtcConfigurationCommandBuilder_:RtcconfigurationCommand.Builder! {
         didSet {
            builderResult.hasRtcConfigurationCommand = true
         }
    }
    public func getRtcConfigurationCommandBuilder() -> RtcconfigurationCommand.Builder {
      if rtcConfigurationCommandBuilder_ == nil {
         rtcConfigurationCommandBuilder_ = RtcconfigurationCommand.Builder()
         builderResult.rtcConfigurationCommand = rtcConfigurationCommandBuilder_.getMessage()
         if rtcConfigurationCommand != nil {
            _ = try! rtcConfigurationCommandBuilder_.mergeFrom(other: rtcConfigurationCommand)
         }
      }
      return rtcConfigurationCommandBuilder_
    }
    public func setRtcConfigurationCommand(_ value:RtcconfigurationCommand!) -> ControlCommand.Builder {
      self.rtcConfigurationCommand = value
      return self
    }
    public func mergeRtcConfigurationCommand(value:RtcconfigurationCommand) throws -> ControlCommand.Builder {
      if builderResult.hasRtcConfigurationCommand {
        builderResult.rtcConfigurationCommand = try RtcconfigurationCommand.builderWithPrototype(prototype: builderResult.rtcConfigurationCommand).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.rtcConfigurationCommand = value
      }
      builderResult.hasRtcConfigurationCommand = true
      return self
    }
    public func clearRtcConfigurationCommand() -> ControlCommand.Builder {
      rtcConfigurationCommandBuilder_ = nil
      builderResult.hasRtcConfigurationCommand = false
      builderResult.rtcConfigurationCommand = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ControlCommand.Builder {
      builderResult = ControlCommand()
      return self
    }
    public override func clone() throws -> ControlCommand.Builder {
      return try ControlCommand.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> ControlCommand {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ControlCommand {
      let returnMe:ControlCommand = builderResult
      return returnMe
    }
    public func mergeFrom(other:ControlCommand) throws -> ControlCommand.Builder {
      if other == ControlCommand() {
       return self
      }
      if other.hasType {
           type = other.type
      }
      if other.hasDiagnosticRequest {
          _ = try mergeDiagnosticRequest(value: other.diagnosticRequest)
      }
      if other.hasPassthroughModeRequest {
          _ = try mergePassthroughModeRequest(value: other.passthroughModeRequest)
      }
      if other.hasAcceptanceFilterBypassCommand {
          _ = try mergeAcceptanceFilterBypassCommand(value: other.acceptanceFilterBypassCommand)
      }
      if other.hasPayloadFormatCommand {
          _ = try mergePayloadFormatCommand(value: other.payloadFormatCommand)
      }
      if other.hasPredefinedObd2RequestsCommand {
          _ = try mergePredefinedObd2RequestsCommand(value: other.predefinedObd2RequestsCommand)
      }
      if other.hasModemConfigurationCommand {
          _ = try mergeModemConfigurationCommand(value: other.modemConfigurationCommand)
      }
      if other.hasRtcConfigurationCommand {
          _ = try mergeRtcConfigurationCommand(value: other.rtcConfigurationCommand)
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFrom(codedInputStream:CodedInputStream) throws -> ControlCommand.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ControlCommand.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueInttype = try codedInputStream.readEnum()
          if let enumstype = ControlCommand.Types.init(rawValue: valueInttype){
               type = enumstype
          } else {
            _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueInttype))
          }

        case 18:
          let subBuilder:DiagnosticControlCommand.Builder = DiagnosticControlCommand.Builder()
          if hasDiagnosticRequest {
           _ = try subBuilder.mergeFrom(other: diagnosticRequest)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          diagnosticRequest = subBuilder.buildPartial()

        case 26:
          let subBuilder:PassthroughModeControlCommand.Builder = PassthroughModeControlCommand.Builder()
          if hasPassthroughModeRequest {
           _ = try subBuilder.mergeFrom(other: passthroughModeRequest)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          passthroughModeRequest = subBuilder.buildPartial()

        case 34:
          let subBuilder:AcceptanceFilterBypassCommand.Builder = AcceptanceFilterBypassCommand.Builder()
          if hasAcceptanceFilterBypassCommand {
           _ = try subBuilder.mergeFrom(other: acceptanceFilterBypassCommand)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          acceptanceFilterBypassCommand = subBuilder.buildPartial()

        case 42:
          let subBuilder:PayloadFormatCommand.Builder = PayloadFormatCommand.Builder()
          if hasPayloadFormatCommand {
           _ = try subBuilder.mergeFrom(other: payloadFormatCommand)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          payloadFormatCommand = subBuilder.buildPartial()

        case 50:
          let subBuilder:PredefinedObd2RequestsCommand.Builder = PredefinedObd2RequestsCommand.Builder()
          if hasPredefinedObd2RequestsCommand {
           _ = try subBuilder.mergeFrom(other: predefinedObd2RequestsCommand)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          predefinedObd2RequestsCommand = subBuilder.buildPartial()

        case 58:
          let subBuilder:ModemConfigurationCommand.Builder = ModemConfigurationCommand.Builder()
          if hasModemConfigurationCommand {
           _ = try subBuilder.mergeFrom(other: modemConfigurationCommand)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          modemConfigurationCommand = subBuilder.buildPartial()

        case 66:
          let subBuilder:RtcconfigurationCommand.Builder = RtcconfigurationCommand.Builder()
          if hasRtcConfigurationCommand {
           _ = try subBuilder.mergeFrom(other: rtcConfigurationCommand)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          rtcConfigurationCommand = subBuilder.buildPartial()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class DiagnosticControlCommand : GeneratedMessage {


    //Enum type declaration start 

    public enum Action:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case add = 1
      case cancel = 2

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
        switch self {
        case .add: return ".add"
        case .cancel: return ".cancel"
        }
      }
    }

    //Enum type declaration end 

  public fileprivate(set) var request:DiagnosticRequest!
  public fileprivate(set) var hasRequest:Bool = false
  public fileprivate(set) var action:DiagnosticControlCommand.Action = DiagnosticControlCommand.Action.add
  public fileprivate(set) var hasAction:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream:CodedOutputStream) throws {
    if hasRequest {
      try codedOutputStream.writeMessage(fieldNumber:1, value:request)
    }
    if hasAction {
      try codedOutputStream.writeEnum(fieldNumber:2, value:action.rawValue)
    }
    try unknownFields.writeTo(codedOutputStream:codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasRequest {
        if let varSizerequest = request?.computeMessageSize(fieldNumber: 1) {
            serialize_size += varSizerequest
        }
    }
    if (hasAction) {
      serialize_size += action.rawValue.computeEnumSize(fieldNumber: 2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> DiagnosticControlCommand.Builder {
    return DiagnosticControlCommand.classBuilder() as! DiagnosticControlCommand.Builder
  }
  public func getBuilder() -> DiagnosticControlCommand.Builder {
    return classBuilder() as! DiagnosticControlCommand.Builder
  }
  public override class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return DiagnosticControlCommand.Builder()
  }
  public override func classBuilder() -> ProtocolBuffersMessageBuilder {
    return DiagnosticControlCommand.Builder()
  }
  public func toBuilder() throws -> DiagnosticControlCommand.Builder {
    return try DiagnosticControlCommand.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:DiagnosticControlCommand) throws -> DiagnosticControlCommand.Builder {
    return try DiagnosticControlCommand.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasRequest {
      output += "\(indent) request {\n"
      if let outDescRequest = request {
        output += try outDescRequest.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if (hasAction) {
      output += "\(indent) action: \(action.description)\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasRequest {
              if let hashValuerequest = request?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuerequest
              }
          }
          if hasAction {
             hashCode = (hashCode &* 31) &+ Int(action.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DiagnosticControlCommand"
  }
  override public func className() -> String {
      return "DiagnosticControlCommand"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:DiagnosticControlCommand = DiagnosticControlCommand()
    public func getMessage() -> DiagnosticControlCommand {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasRequest:Bool {
         get {
             return builderResult.hasRequest
         }
    }
    public var request:DiagnosticRequest! {
         get {
             if requestBuilder_ != nil {
                builderResult.request = requestBuilder_.getMessage()
             }
             return builderResult.request
         }
         set (value) {
             builderResult.hasRequest = true
             builderResult.request = value
         }
    }
    private var requestBuilder_:DiagnosticRequest.Builder! {
         didSet {
            builderResult.hasRequest = true
         }
    }
    public func getRequestBuilder() -> DiagnosticRequest.Builder {
      if requestBuilder_ == nil {
         requestBuilder_ = DiagnosticRequest.Builder()
         builderResult.request = requestBuilder_.getMessage()
         if request != nil {
            _ = try! requestBuilder_.mergeFrom(other: request)
         }
      }
      return requestBuilder_
    }
    public func setRequest(_ value:DiagnosticRequest!) -> DiagnosticControlCommand.Builder {
      self.request = value
      return self
    }
    public func mergeRequest(value:DiagnosticRequest) throws -> DiagnosticControlCommand.Builder {
      if builderResult.hasRequest {
        builderResult.request = try DiagnosticRequest.builderWithPrototype(prototype: builderResult.request).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.request = value
      }
      builderResult.hasRequest = true
      return self
    }
    public func clearRequest() -> DiagnosticControlCommand.Builder {
      requestBuilder_ = nil
      builderResult.hasRequest = false
      builderResult.request = nil
      return self
    }
      public var hasAction:Bool{
          get {
              return builderResult.hasAction
          }
      }
      public var action:DiagnosticControlCommand.Action {
          get {
              return builderResult.action
          }
          set (value) {
              builderResult.hasAction = true
              builderResult.action = value
          }
      }
      public func setAction(_ value:DiagnosticControlCommand.Action) -> DiagnosticControlCommand.Builder {
        self.action = value
        return self
      }
      public func clearAction() -> DiagnosticControlCommand.Builder {
         builderResult.hasAction = false
         builderResult.action = .add
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> DiagnosticControlCommand.Builder {
      builderResult = DiagnosticControlCommand()
      return self
    }
    public override func clone() throws -> DiagnosticControlCommand.Builder {
      return try DiagnosticControlCommand.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> DiagnosticControlCommand {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DiagnosticControlCommand {
      let returnMe:DiagnosticControlCommand = builderResult
      return returnMe
    }
    public func mergeFrom(other:DiagnosticControlCommand) throws -> DiagnosticControlCommand.Builder {
      if other == DiagnosticControlCommand() {
       return self
      }
      if other.hasRequest {
          _ = try mergeRequest(value: other.request)
      }
      if other.hasAction {
           action = other.action
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFrom(codedInputStream:CodedInputStream) throws -> DiagnosticControlCommand.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DiagnosticControlCommand.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:DiagnosticRequest.Builder = DiagnosticRequest.Builder()
          if hasRequest {
           _ = try subBuilder.mergeFrom(other: request)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          request = subBuilder.buildPartial()

        case 16:
          let valueIntaction = try codedInputStream.readEnum()
          if let enumsaction = DiagnosticControlCommand.Action(rawValue:valueIntaction){
               action = enumsaction
          } else {
            _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntaction))
          }

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class PassthroughModeControlCommand : GeneratedMessage {
  public fileprivate(set) var bus:Int32 = Int32(0)

  public fileprivate(set) var hasBus:Bool = false
  public fileprivate(set) var enabled:Bool = false

  public fileprivate(set) var hasEnabled:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream:CodedOutputStream) throws {
    if hasBus {
      try codedOutputStream.writeInt32(fieldNumber:1, value:bus)
    }
    if hasEnabled {
      try codedOutputStream.writeBool(fieldNumber:2, value:enabled)
    }
    try unknownFields.writeTo(codedOutputStream:codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasBus {
      serialize_size += bus.computeInt32Size(fieldNumber: 1)
    }
    if hasEnabled {
      serialize_size += enabled.computeBoolSize(fieldNumber: 2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> PassthroughModeControlCommand.Builder {
    return PassthroughModeControlCommand.classBuilder() as! PassthroughModeControlCommand.Builder
  }
  public func getBuilder() -> PassthroughModeControlCommand.Builder {
    return classBuilder() as! PassthroughModeControlCommand.Builder
  }
  public override class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return PassthroughModeControlCommand.Builder()
  }
  public override func classBuilder() -> ProtocolBuffersMessageBuilder {
    return PassthroughModeControlCommand.Builder()
  }
  public func toBuilder() throws -> PassthroughModeControlCommand.Builder {
    return try PassthroughModeControlCommand.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:PassthroughModeControlCommand) throws -> PassthroughModeControlCommand.Builder {
    return try PassthroughModeControlCommand.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasBus {
      output += "\(indent) bus: \(bus) \n"
    }
    if hasEnabled {
      output += "\(indent) enabled: \(enabled) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasBus {
             hashCode = (hashCode &* 31) &+ bus.hashValue
          }
          if hasEnabled {
             hashCode = (hashCode &* 31) &+ enabled.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PassthroughModeControlCommand"
  }
  override public func className() -> String {
      return "PassthroughModeControlCommand"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PassthroughModeControlCommand = PassthroughModeControlCommand()
    public func getMessage() -> PassthroughModeControlCommand {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasBus:Bool {
         get {
              return builderResult.hasBus
         }
    }
    public var bus:Int32 {
         get {
              return builderResult.bus
         }
         set (value) {
             builderResult.hasBus = true
             builderResult.bus = value
         }
    }
    public func setBus(_ value:Int32) -> PassthroughModeControlCommand.Builder {
      self.bus = value
      return self
    }
    public func clearBus() -> PassthroughModeControlCommand.Builder{
         builderResult.hasBus = false
         builderResult.bus = Int32(0)
         return self
    }
    public var hasEnabled:Bool {
         get {
              return builderResult.hasEnabled
         }
    }
    public var enabled:Bool {
         get {
              return builderResult.enabled
         }
         set (value) {
             builderResult.hasEnabled = true
             builderResult.enabled = value
         }
    }
    public func setEnabled(_ value:Bool) -> PassthroughModeControlCommand.Builder {
      self.enabled = value
      return self
    }
    public func clearEnabled() -> PassthroughModeControlCommand.Builder{
         builderResult.hasEnabled = false
         builderResult.enabled = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> PassthroughModeControlCommand.Builder {
      builderResult = PassthroughModeControlCommand()
      return self
    }
    public override func clone() throws -> PassthroughModeControlCommand.Builder {
      return try PassthroughModeControlCommand.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> PassthroughModeControlCommand {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PassthroughModeControlCommand {
      let returnMe:PassthroughModeControlCommand = builderResult
      return returnMe
    }
    public func mergeFrom(other:PassthroughModeControlCommand) throws -> PassthroughModeControlCommand.Builder {
      if other == PassthroughModeControlCommand() {
       return self
      }
      if other.hasBus {
           bus = other.bus
      }
      if other.hasEnabled {
           enabled = other.enabled
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFrom(codedInputStream:CodedInputStream) throws -> PassthroughModeControlCommand.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PassthroughModeControlCommand.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          bus = try codedInputStream.readInt32()

        case 16:
          enabled = try codedInputStream.readBool()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class AcceptanceFilterBypassCommand : GeneratedMessage {
  public fileprivate(set) var bus:Int32 = Int32(0)

  public fileprivate(set) var hasBus:Bool = false
  public fileprivate(set) var bypass:Bool = false

  public fileprivate(set) var hasBypass:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream:CodedOutputStream) throws {
    if hasBus {
      try codedOutputStream.writeInt32(fieldNumber:1, value:bus)
    }
    if hasBypass {
      try codedOutputStream.writeBool(fieldNumber:2, value:bypass)
    }
    try unknownFields.writeTo(codedOutputStream:codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasBus {
      serialize_size += bus.computeInt32Size(fieldNumber: 1)
    }
    if hasBypass {
      serialize_size += bypass.computeBoolSize(fieldNumber: 2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> AcceptanceFilterBypassCommand.Builder {
    return AcceptanceFilterBypassCommand.classBuilder() as! AcceptanceFilterBypassCommand.Builder
  }
  public func getBuilder() -> AcceptanceFilterBypassCommand.Builder {
    return classBuilder() as! AcceptanceFilterBypassCommand.Builder
  }
  public override class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return AcceptanceFilterBypassCommand.Builder()
  }
  public override func classBuilder() -> ProtocolBuffersMessageBuilder {
    return AcceptanceFilterBypassCommand.Builder()
  }
  public func toBuilder() throws -> AcceptanceFilterBypassCommand.Builder {
    return try AcceptanceFilterBypassCommand.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:AcceptanceFilterBypassCommand) throws -> AcceptanceFilterBypassCommand.Builder {
    return try AcceptanceFilterBypassCommand.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasBus {
      output += "\(indent) bus: \(bus) \n"
    }
    if hasBypass {
      output += "\(indent) bypass: \(bypass) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasBus {
             hashCode = (hashCode &* 31) &+ bus.hashValue
          }
          if hasBypass {
             hashCode = (hashCode &* 31) &+ bypass.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "AcceptanceFilterBypassCommand"
  }
  override public func className() -> String {
      return "AcceptanceFilterBypassCommand"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:AcceptanceFilterBypassCommand = AcceptanceFilterBypassCommand()
    public func getMessage() -> AcceptanceFilterBypassCommand {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasBus:Bool {
         get {
              return builderResult.hasBus
         }
    }
    public var bus:Int32 {
         get {
              return builderResult.bus
         }
         set (value) {
             builderResult.hasBus = true
             builderResult.bus = value
         }
    }
    public func setBus(_ value:Int32) -> AcceptanceFilterBypassCommand.Builder {
      self.bus = value
      return self
    }
    public func clearBus() -> AcceptanceFilterBypassCommand.Builder{
         builderResult.hasBus = false
         builderResult.bus = Int32(0)
         return self
    }
    public var hasBypass:Bool {
         get {
              return builderResult.hasBypass
         }
    }
    public var bypass:Bool {
         get {
              return builderResult.bypass
         }
         set (value) {
             builderResult.hasBypass = true
             builderResult.bypass = value
         }
    }
    public func setBypass(_ value:Bool) -> AcceptanceFilterBypassCommand.Builder {
      self.bypass = value
      return self
    }
    public func clearBypass() -> AcceptanceFilterBypassCommand.Builder{
         builderResult.hasBypass = false
         builderResult.bypass = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> AcceptanceFilterBypassCommand.Builder {
      builderResult = AcceptanceFilterBypassCommand()
      return self
    }
    public override func clone() throws -> AcceptanceFilterBypassCommand.Builder {
      return try AcceptanceFilterBypassCommand.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> AcceptanceFilterBypassCommand {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> AcceptanceFilterBypassCommand {
      let returnMe:AcceptanceFilterBypassCommand = builderResult
      return returnMe
    }
    public func mergeFrom(other:AcceptanceFilterBypassCommand) throws -> AcceptanceFilterBypassCommand.Builder {
      if other == AcceptanceFilterBypassCommand() {
       return self
      }
      if other.hasBus {
           bus = other.bus
      }
      if other.hasBypass {
           bypass = other.bypass
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFrom(codedInputStream:CodedInputStream) throws -> AcceptanceFilterBypassCommand.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AcceptanceFilterBypassCommand.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          bus = try codedInputStream.readInt32()

        case 16:
          bypass = try codedInputStream.readBool()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class PayloadFormatCommand : GeneratedMessage {


    //Enum type declaration start 

    public enum PayloadFormat:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case json = 1
      case protobuf = 2
      case messagepack = 3

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
        switch self {
        case .json: return ".json"
        case .protobuf: return ".protobuf"
        case .messagepack: return ".messagepack"
        }
      }
    }

    //Enum type declaration end 

  public fileprivate(set) var format:PayloadFormatCommand.PayloadFormat = PayloadFormatCommand.PayloadFormat.json
  public fileprivate(set) var hasFormat:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream:CodedOutputStream) throws {
    if hasFormat {
      try codedOutputStream.writeEnum(fieldNumber:1, value:format.rawValue)
    }
    try unknownFields.writeTo(codedOutputStream:codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasFormat) {
      serialize_size += format.rawValue.computeEnumSize(fieldNumber: 1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> PayloadFormatCommand.Builder {
    return PayloadFormatCommand.classBuilder() as! PayloadFormatCommand.Builder
  }
  public func getBuilder() -> PayloadFormatCommand.Builder {
    return classBuilder() as! PayloadFormatCommand.Builder
  }
  public override class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return PayloadFormatCommand.Builder()
  }
  public override func classBuilder() -> ProtocolBuffersMessageBuilder {
    return PayloadFormatCommand.Builder()
  }
  public func toBuilder() throws -> PayloadFormatCommand.Builder {
    return try PayloadFormatCommand.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:PayloadFormatCommand) throws -> PayloadFormatCommand.Builder {
    return try PayloadFormatCommand.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if (hasFormat) {
      output += "\(indent) format: \(format.description)\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasFormat {
             hashCode = (hashCode &* 31) &+ Int(format.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PayloadFormatCommand"
  }
  override public func className() -> String {
      return "PayloadFormatCommand"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PayloadFormatCommand = PayloadFormatCommand()
    public func getMessage() -> PayloadFormatCommand {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasFormat:Bool{
          get {
              return builderResult.hasFormat
          }
      }
      public var format:PayloadFormatCommand.PayloadFormat {
          get {
              return builderResult.format
          }
          set (value) {
              builderResult.hasFormat = true
              builderResult.format = value
          }
      }
      public func setFormat(_ value:PayloadFormatCommand.PayloadFormat) -> PayloadFormatCommand.Builder {
        self.format = value
        return self
      }
      public func clearFormat() -> PayloadFormatCommand.Builder {
         builderResult.hasFormat = false
         builderResult.format = .json
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> PayloadFormatCommand.Builder {
      builderResult = PayloadFormatCommand()
      return self
    }
    public override func clone() throws -> PayloadFormatCommand.Builder {
      return try PayloadFormatCommand.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> PayloadFormatCommand {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PayloadFormatCommand {
      let returnMe:PayloadFormatCommand = builderResult
      return returnMe
    }
    public func mergeFrom(other:PayloadFormatCommand) throws -> PayloadFormatCommand.Builder {
      if other == PayloadFormatCommand() {
       return self
      }
      if other.hasFormat {
           format = other.format
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFrom(codedInputStream:CodedInputStream) throws -> PayloadFormatCommand.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PayloadFormatCommand.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueIntformat = try codedInputStream.readEnum()
          if let enumsformat = PayloadFormatCommand.PayloadFormat(rawValue:valueIntformat){
               format = enumsformat
          } else {
            _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntformat))
          }

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class PredefinedObd2RequestsCommand : GeneratedMessage {
  public fileprivate(set) var enabled:Bool = false

  public fileprivate(set) var hasEnabled:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream:CodedOutputStream) throws {
    if hasEnabled {
      try codedOutputStream.writeBool(fieldNumber:1, value:enabled)
    }
    try unknownFields.writeTo(codedOutputStream:codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasEnabled {
      serialize_size += enabled.computeBoolSize(fieldNumber: 1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> PredefinedObd2RequestsCommand.Builder {
    return PredefinedObd2RequestsCommand.classBuilder() as! PredefinedObd2RequestsCommand.Builder
  }
  public func getBuilder() -> PredefinedObd2RequestsCommand.Builder {
    return classBuilder() as! PredefinedObd2RequestsCommand.Builder
  }
  public override class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return PredefinedObd2RequestsCommand.Builder()
  }
  public override func classBuilder() -> ProtocolBuffersMessageBuilder {
    return PredefinedObd2RequestsCommand.Builder()
  }
  public func toBuilder() throws -> PredefinedObd2RequestsCommand.Builder {
    return try PredefinedObd2RequestsCommand.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:PredefinedObd2RequestsCommand) throws -> PredefinedObd2RequestsCommand.Builder {
    return try PredefinedObd2RequestsCommand.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasEnabled {
      output += "\(indent) enabled: \(enabled) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasEnabled {
             hashCode = (hashCode &* 31) &+ enabled.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "PredefinedObd2RequestsCommand"
  }
  override public func className() -> String {
      return "PredefinedObd2RequestsCommand"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:PredefinedObd2RequestsCommand = PredefinedObd2RequestsCommand()
    public func getMessage() -> PredefinedObd2RequestsCommand {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasEnabled:Bool {
         get {
              return builderResult.hasEnabled
         }
    }
    public var enabled:Bool {
         get {
              return builderResult.enabled
         }
         set (value) {
             builderResult.hasEnabled = true
             builderResult.enabled = value
         }
    }
    public func setEnabled(_ value:Bool) -> PredefinedObd2RequestsCommand.Builder {
      self.enabled = value
      return self
    }
    public func clearEnabled() -> PredefinedObd2RequestsCommand.Builder{
         builderResult.hasEnabled = false
         builderResult.enabled = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> PredefinedObd2RequestsCommand.Builder {
      builderResult = PredefinedObd2RequestsCommand()
      return self
    }
    public override func clone() throws -> PredefinedObd2RequestsCommand.Builder {
      return try PredefinedObd2RequestsCommand.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> PredefinedObd2RequestsCommand {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> PredefinedObd2RequestsCommand {
      let returnMe:PredefinedObd2RequestsCommand = builderResult
      return returnMe
    }
    public func mergeFrom(other:PredefinedObd2RequestsCommand) throws -> PredefinedObd2RequestsCommand.Builder {
      if other == PredefinedObd2RequestsCommand() {
       return self
      }
      if other.hasEnabled {
           enabled = other.enabled
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFrom(codedInputStream:CodedInputStream) throws -> PredefinedObd2RequestsCommand.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PredefinedObd2RequestsCommand.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          enabled = try codedInputStream.readBool()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class NetworkOperatorSettings : GeneratedMessage {


  //Nested type declaration start

    final public class NetworkDescriptor : GeneratedMessage {


        //Enum type declaration start 

        public enum NetworkType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
          case gsm = 0
          case utran = 2

          public var debugDescription:String { return getDescription() }
          public var description:String { return getDescription() }
          private func getDescription() -> String { 
            switch self {
            case .gsm: return ".gsm"
            case .utran: return ".utran"
            }
          }
        }

        //Enum type declaration end 

      public fileprivate(set) var plmn:UInt32 = UInt32(0)

      public fileprivate(set) var hasPlmn:Bool = false
      public fileprivate(set) var networkType:NetworkOperatorSettings.NetworkDescriptor.NetworkType = NetworkOperatorSettings.NetworkDescriptor.NetworkType.gsm
      public fileprivate(set) var hasNetworkType:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeTo(codedOutputStream:CodedOutputStream) throws {
        if hasPlmn {
          try codedOutputStream.writeUInt32(fieldNumber:1, value:plmn)
        }
        if hasNetworkType {
          try codedOutputStream.writeEnum(fieldNumber:2, value:networkType.rawValue)
        }
        try unknownFields.writeTo(codedOutputStream:codedOutputStream)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasPlmn {
          serialize_size += plmn.computeUInt32Size(fieldNumber: 1)
        }
        if (hasNetworkType) {
          serialize_size += networkType.rawValue.computeEnumSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func getBuilder() -> NetworkOperatorSettings.NetworkDescriptor.Builder {
        return NetworkOperatorSettings.NetworkDescriptor.classBuilder() as! NetworkOperatorSettings.NetworkDescriptor.Builder
      }
      public func getBuilder() -> NetworkOperatorSettings.NetworkDescriptor.Builder {
        return classBuilder() as! NetworkOperatorSettings.NetworkDescriptor.Builder
      }
      public override class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return NetworkOperatorSettings.NetworkDescriptor.Builder()
      }
      public override func classBuilder() -> ProtocolBuffersMessageBuilder {
        return NetworkOperatorSettings.NetworkDescriptor.Builder()
      }
      public func toBuilder() throws -> NetworkOperatorSettings.NetworkDescriptor.Builder {
        return try NetworkOperatorSettings.NetworkDescriptor.builderWithPrototype(prototype: self)
      }
      public class func builderWithPrototype(prototype:NetworkOperatorSettings.NetworkDescriptor) throws -> NetworkOperatorSettings.NetworkDescriptor.Builder {
        return try NetworkOperatorSettings.NetworkDescriptor.Builder().mergeFrom(other: prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasPlmn {
          output += "\(indent) plmn: \(plmn) \n"
        }
        if (hasNetworkType) {
          output += "\(indent) networkType: \(networkType.description)\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasPlmn {
                 hashCode = (hashCode &* 31) &+ plmn.hashValue
              }
              if hasNetworkType {
                 hashCode = (hashCode &* 31) &+ Int(networkType.rawValue)
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "NetworkOperatorSettings.NetworkDescriptor"
      }
      override public func className() -> String {
          return "NetworkOperatorSettings.NetworkDescriptor"
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:NetworkOperatorSettings.NetworkDescriptor = NetworkOperatorSettings.NetworkDescriptor()
        public func getMessage() -> NetworkOperatorSettings.NetworkDescriptor {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasPlmn:Bool {
             get {
                  return builderResult.hasPlmn
             }
        }
        public var plmn:UInt32 {
             get {
                  return builderResult.plmn
             }
             set (value) {
                 builderResult.hasPlmn = true
                 builderResult.plmn = value
             }
        }
        public func setPlmn(_ value:UInt32) -> NetworkOperatorSettings.NetworkDescriptor.Builder {
          self.plmn = value
          return self
        }
        public func clearPlmn() -> NetworkOperatorSettings.NetworkDescriptor.Builder{
             builderResult.hasPlmn = false
             builderResult.plmn = UInt32(0)
             return self
        }
          public var hasNetworkType:Bool{
              get {
                  return builderResult.hasNetworkType
              }
          }
          public var networkType:NetworkOperatorSettings.NetworkDescriptor.NetworkType {
              get {
                  return builderResult.networkType
              }
              set (value) {
                  builderResult.hasNetworkType = true
                  builderResult.networkType = value
              }
          }
          public func setNetworkType(_ value:NetworkOperatorSettings.NetworkDescriptor.NetworkType) -> NetworkOperatorSettings.NetworkDescriptor.Builder {
            self.networkType = value
            return self
          }
          public func clearNetworkType() -> NetworkOperatorSettings.NetworkDescriptor.Builder {
             builderResult.hasNetworkType = false
             builderResult.networkType = .gsm
             return self
          }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> NetworkOperatorSettings.NetworkDescriptor.Builder {
          builderResult = NetworkOperatorSettings.NetworkDescriptor()
          return self
        }
        public override func clone() throws -> NetworkOperatorSettings.NetworkDescriptor.Builder {
          return try NetworkOperatorSettings.NetworkDescriptor.builderWithPrototype(prototype: builderResult)
        }
        public override func build() throws -> NetworkOperatorSettings.NetworkDescriptor {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> NetworkOperatorSettings.NetworkDescriptor {
          let returnMe:NetworkOperatorSettings.NetworkDescriptor = builderResult
          return returnMe
        }
        public func mergeFrom(other:NetworkOperatorSettings.NetworkDescriptor) throws -> NetworkOperatorSettings.NetworkDescriptor.Builder {
          if other == NetworkOperatorSettings.NetworkDescriptor() {
           return self
          }
          if other.hasPlmn {
               plmn = other.plmn
          }
          if other.hasNetworkType {
               networkType = other.networkType
          }
          _ = try merge(unknownField: other.unknownFields)
          return self
        }
        public override func mergeFrom(codedInputStream:CodedInputStream) throws -> NetworkOperatorSettings.NetworkDescriptor.Builder {
             return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> NetworkOperatorSettings.NetworkDescriptor.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
          while (true) {
            let protobufTag = try codedInputStream.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8:
              plmn = try codedInputStream.readUInt32()

            case 16:
              let valueIntnetworkType = try codedInputStream.readEnum()
              if let enumsnetworkType = NetworkOperatorSettings.NetworkDescriptor.NetworkType(rawValue:valueIntnetworkType){
                   networkType = enumsnetworkType
              } else {
                _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntnetworkType))
              }

            default:
              if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



    //Enum type declaration start 

    public enum OperatorSelectMode:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case automatic = 0
      case manual = 1
      case deregister = 2
      case setOnly = 3
      case manualAutomatic = 4

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
        switch self {
        case .automatic: return ".automatic"
        case .manual: return ".manual"
        case .deregister: return ".deregister"
        case .setOnly: return ".setOnly"
        case .manualAutomatic: return ".manualAutomatic"
        }
      }
    }

    //Enum type declaration end 

  public fileprivate(set) var allowDataRoaming:Bool = false

  public fileprivate(set) var hasAllowDataRoaming:Bool = false
  public fileprivate(set) var operatorSelectMode:NetworkOperatorSettings.OperatorSelectMode = NetworkOperatorSettings.OperatorSelectMode.automatic
  public fileprivate(set) var hasOperatorSelectMode:Bool = false
  public fileprivate(set) var networkDescriptor:NetworkOperatorSettings.NetworkDescriptor!
  public fileprivate(set) var hasNetworkDescriptor:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream:CodedOutputStream) throws {
    if hasAllowDataRoaming {
      try codedOutputStream.writeBool(fieldNumber:1, value:allowDataRoaming)
    }
    if hasOperatorSelectMode {
      try codedOutputStream.writeEnum(fieldNumber:2, value:operatorSelectMode.rawValue)
    }
    if hasNetworkDescriptor {
      try codedOutputStream.writeMessage(fieldNumber:3, value:networkDescriptor)
    }
    try unknownFields.writeTo(codedOutputStream:codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasAllowDataRoaming {
      serialize_size += allowDataRoaming.computeBoolSize(fieldNumber: 1)
    }
    if (hasOperatorSelectMode) {
      serialize_size += operatorSelectMode.rawValue.computeEnumSize(fieldNumber: 2)
    }
    if hasNetworkDescriptor {
        if let varSizenetworkDescriptor = networkDescriptor?.computeMessageSize(fieldNumber: 3) {
            serialize_size += varSizenetworkDescriptor
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> NetworkOperatorSettings.Builder {
    return NetworkOperatorSettings.classBuilder() as! NetworkOperatorSettings.Builder
  }
  public func getBuilder() -> NetworkOperatorSettings.Builder {
    return classBuilder() as! NetworkOperatorSettings.Builder
  }
  public override class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return NetworkOperatorSettings.Builder()
  }
  public override func classBuilder() -> ProtocolBuffersMessageBuilder {
    return NetworkOperatorSettings.Builder()
  }
  public func toBuilder() throws -> NetworkOperatorSettings.Builder {
    return try NetworkOperatorSettings.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:NetworkOperatorSettings) throws -> NetworkOperatorSettings.Builder {
    return try NetworkOperatorSettings.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasAllowDataRoaming {
      output += "\(indent) allowDataRoaming: \(allowDataRoaming) \n"
    }
    if (hasOperatorSelectMode) {
      output += "\(indent) operatorSelectMode: \(operatorSelectMode.description)\n"
    }
    if hasNetworkDescriptor {
      output += "\(indent) networkDescriptor {\n"
      if let outDescNetworkDescriptor = networkDescriptor {
        output += try outDescNetworkDescriptor.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasAllowDataRoaming {
             hashCode = (hashCode &* 31) &+ allowDataRoaming.hashValue
          }
          if hasOperatorSelectMode {
             hashCode = (hashCode &* 31) &+ Int(operatorSelectMode.rawValue)
          }
          if hasNetworkDescriptor {
              if let hashValuenetworkDescriptor = networkDescriptor?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuenetworkDescriptor
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "NetworkOperatorSettings"
  }
  override public func className() -> String {
      return "NetworkOperatorSettings"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:NetworkOperatorSettings = NetworkOperatorSettings()
    public func getMessage() -> NetworkOperatorSettings {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasAllowDataRoaming:Bool {
         get {
              return builderResult.hasAllowDataRoaming
         }
    }
    public var allowDataRoaming:Bool {
         get {
              return builderResult.allowDataRoaming
         }
         set (value) {
             builderResult.hasAllowDataRoaming = true
             builderResult.allowDataRoaming = value
         }
    }
    public func setAllowDataRoaming(_ value:Bool) -> NetworkOperatorSettings.Builder {
      self.allowDataRoaming = value
      return self
    }
    public func clearAllowDataRoaming() -> NetworkOperatorSettings.Builder{
         builderResult.hasAllowDataRoaming = false
         builderResult.allowDataRoaming = false
         return self
    }
      public var hasOperatorSelectMode:Bool{
          get {
              return builderResult.hasOperatorSelectMode
          }
      }
      public var operatorSelectMode:NetworkOperatorSettings.OperatorSelectMode {
          get {
              return builderResult.operatorSelectMode
          }
          set (value) {
              builderResult.hasOperatorSelectMode = true
              builderResult.operatorSelectMode = value
          }
      }
      public func setOperatorSelectMode(_ value:NetworkOperatorSettings.OperatorSelectMode) -> NetworkOperatorSettings.Builder {
        self.operatorSelectMode = value
        return self
      }
      public func clearOperatorSelectMode() -> NetworkOperatorSettings.Builder {
         builderResult.hasOperatorSelectMode = false
         builderResult.operatorSelectMode = .automatic
         return self
      }
    public var hasNetworkDescriptor:Bool {
         get {
             return builderResult.hasNetworkDescriptor
         }
    }
    public var networkDescriptor:NetworkOperatorSettings.NetworkDescriptor! {
         get {
             if networkDescriptorBuilder_ != nil {
                builderResult.networkDescriptor = networkDescriptorBuilder_.getMessage()
             }
             return builderResult.networkDescriptor
         }
         set (value) {
             builderResult.hasNetworkDescriptor = true
             builderResult.networkDescriptor = value
         }
    }
    private var networkDescriptorBuilder_:NetworkOperatorSettings.NetworkDescriptor.Builder! {
         didSet {
            builderResult.hasNetworkDescriptor = true
         }
    }
    public func getNetworkDescriptorBuilder() -> NetworkOperatorSettings.NetworkDescriptor.Builder {
      if networkDescriptorBuilder_ == nil {
         networkDescriptorBuilder_ = NetworkOperatorSettings.NetworkDescriptor.Builder()
         builderResult.networkDescriptor = networkDescriptorBuilder_.getMessage()
         if networkDescriptor != nil {
            _ = try! networkDescriptorBuilder_.mergeFrom(other: networkDescriptor)
         }
      }
      return networkDescriptorBuilder_
    }
    public func setNetworkDescriptor(_ value:NetworkOperatorSettings.NetworkDescriptor!) -> NetworkOperatorSettings.Builder {
      self.networkDescriptor = value
      return self
    }
    public func mergeNetworkDescriptor(value:NetworkOperatorSettings.NetworkDescriptor) throws -> NetworkOperatorSettings.Builder {
      if builderResult.hasNetworkDescriptor {
        builderResult.networkDescriptor = try NetworkOperatorSettings.NetworkDescriptor.builderWithPrototype(prototype: builderResult.networkDescriptor).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.networkDescriptor = value
      }
      builderResult.hasNetworkDescriptor = true
      return self
    }
    public func clearNetworkDescriptor() -> NetworkOperatorSettings.Builder {
      networkDescriptorBuilder_ = nil
      builderResult.hasNetworkDescriptor = false
      builderResult.networkDescriptor = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> NetworkOperatorSettings.Builder {
      builderResult = NetworkOperatorSettings()
      return self
    }
    public override func clone() throws -> NetworkOperatorSettings.Builder {
      return try NetworkOperatorSettings.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> NetworkOperatorSettings {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> NetworkOperatorSettings {
      let returnMe:NetworkOperatorSettings = builderResult
      return returnMe
    }
    public func mergeFrom(other:NetworkOperatorSettings) throws -> NetworkOperatorSettings.Builder {
      if other == NetworkOperatorSettings() {
       return self
      }
      if other.hasAllowDataRoaming {
           allowDataRoaming = other.allowDataRoaming
      }
      if other.hasOperatorSelectMode {
           operatorSelectMode = other.operatorSelectMode
      }
      if other.hasNetworkDescriptor {
          _ = try mergeNetworkDescriptor(value: other.networkDescriptor)
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFrom(codedInputStream:CodedInputStream) throws -> NetworkOperatorSettings.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> NetworkOperatorSettings.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          allowDataRoaming = try codedInputStream.readBool()

        case 16:
          let valueIntoperatorSelectMode = try codedInputStream.readEnum()
          if let enumsoperatorSelectMode = NetworkOperatorSettings.OperatorSelectMode(rawValue:valueIntoperatorSelectMode){
               operatorSelectMode = enumsoperatorSelectMode
          } else {
            _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntoperatorSelectMode))
          }

        case 26:
          let subBuilder:NetworkOperatorSettings.NetworkDescriptor.Builder = NetworkOperatorSettings.NetworkDescriptor.Builder()
          if hasNetworkDescriptor {
           _ = try subBuilder.mergeFrom(other: networkDescriptor)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          networkDescriptor = subBuilder.buildPartial()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class NetworkDataSettings : GeneratedMessage {
  public fileprivate(set) var apn:String = ""

  public fileprivate(set) var hasApn:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream:CodedOutputStream) throws {
    if hasApn {
      try codedOutputStream.writeString(fieldNumber:1, value:apn)
    }
    try unknownFields.writeTo(codedOutputStream:codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasApn {
      serialize_size += apn.computeStringSize(fieldNumber: 1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> NetworkDataSettings.Builder {
    return NetworkDataSettings.classBuilder() as! NetworkDataSettings.Builder
  }
  public func getBuilder() -> NetworkDataSettings.Builder {
    return classBuilder() as! NetworkDataSettings.Builder
  }
  public override class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return NetworkDataSettings.Builder()
  }
  public override func classBuilder() -> ProtocolBuffersMessageBuilder {
    return NetworkDataSettings.Builder()
  }
  public func toBuilder() throws -> NetworkDataSettings.Builder {
    return try NetworkDataSettings.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:NetworkDataSettings) throws -> NetworkDataSettings.Builder {
    return try NetworkDataSettings.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasApn {
      output += "\(indent) apn: \(apn) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasApn {
             hashCode = (hashCode &* 31) &+ apn.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "NetworkDataSettings"
  }
  override public func className() -> String {
      return "NetworkDataSettings"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:NetworkDataSettings = NetworkDataSettings()
    public func getMessage() -> NetworkDataSettings {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasApn:Bool {
         get {
              return builderResult.hasApn
         }
    }
    public var apn:String {
         get {
              return builderResult.apn
         }
         set (value) {
             builderResult.hasApn = true
             builderResult.apn = value
         }
    }
    public func setApn(_ value:String) -> NetworkDataSettings.Builder {
      self.apn = value
      return self
    }
    public func clearApn() -> NetworkDataSettings.Builder{
         builderResult.hasApn = false
         builderResult.apn = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> NetworkDataSettings.Builder {
      builderResult = NetworkDataSettings()
      return self
    }
    public override func clone() throws -> NetworkDataSettings.Builder {
      return try NetworkDataSettings.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> NetworkDataSettings {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> NetworkDataSettings {
      let returnMe:NetworkDataSettings = builderResult
      return returnMe
    }
    public func mergeFrom(other:NetworkDataSettings) throws -> NetworkDataSettings.Builder {
      if other == NetworkDataSettings() {
       return self
      }
      if other.hasApn {
           apn = other.apn
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFrom(codedInputStream:CodedInputStream) throws -> NetworkDataSettings.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> NetworkDataSettings.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          apn = try codedInputStream.readString()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ServerConnectSettings : GeneratedMessage {
  public fileprivate(set) var host:String = ""

  public fileprivate(set) var hasHost:Bool = false
  public fileprivate(set) var port:UInt32 = UInt32(0)

  public fileprivate(set) var hasPort:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream:CodedOutputStream) throws {
    if hasHost {
      try codedOutputStream.writeString(fieldNumber:1, value:host)
    }
    if hasPort {
      try codedOutputStream.writeUInt32(fieldNumber:2, value:port)
    }
    try unknownFields.writeTo(codedOutputStream:codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasHost {
      serialize_size += host.computeStringSize(fieldNumber: 1)
    }
    if hasPort {
      serialize_size += port.computeUInt32Size(fieldNumber: 2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> ServerConnectSettings.Builder {
    return ServerConnectSettings.classBuilder() as! ServerConnectSettings.Builder
  }
  public func getBuilder() -> ServerConnectSettings.Builder {
    return classBuilder() as! ServerConnectSettings.Builder
  }
  public override class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return ServerConnectSettings.Builder()
  }
  public override func classBuilder() -> ProtocolBuffersMessageBuilder {
    return ServerConnectSettings.Builder()
  }
  public func toBuilder() throws -> ServerConnectSettings.Builder {
    return try ServerConnectSettings.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:ServerConnectSettings) throws -> ServerConnectSettings.Builder {
    return try ServerConnectSettings.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasHost {
      output += "\(indent) host: \(host) \n"
    }
    if hasPort {
      output += "\(indent) port: \(port) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasHost {
             hashCode = (hashCode &* 31) &+ host.hashValue
          }
          if hasPort {
             hashCode = (hashCode &* 31) &+ port.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ServerConnectSettings"
  }
  override public func className() -> String {
      return "ServerConnectSettings"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ServerConnectSettings = ServerConnectSettings()
    public func getMessage() -> ServerConnectSettings {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasHost:Bool {
         get {
              return builderResult.hasHost
         }
    }
    public var host:String {
         get {
              return builderResult.host
         }
         set (value) {
             builderResult.hasHost = true
             builderResult.host = value
         }
    }
    public func setHost(_ value:String) -> ServerConnectSettings.Builder {
      self.host = value
      return self
    }
    public func clearHost() -> ServerConnectSettings.Builder{
         builderResult.hasHost = false
         builderResult.host = ""
         return self
    }
    public var hasPort:Bool {
         get {
              return builderResult.hasPort
         }
    }
    public var port:UInt32 {
         get {
              return builderResult.port
         }
         set (value) {
             builderResult.hasPort = true
             builderResult.port = value
         }
    }
    public func setPort(_ value:UInt32) -> ServerConnectSettings.Builder {
      self.port = value
      return self
    }
    public func clearPort() -> ServerConnectSettings.Builder{
         builderResult.hasPort = false
         builderResult.port = UInt32(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ServerConnectSettings.Builder {
      builderResult = ServerConnectSettings()
      return self
    }
    public override func clone() throws -> ServerConnectSettings.Builder {
      return try ServerConnectSettings.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> ServerConnectSettings {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ServerConnectSettings {
      let returnMe:ServerConnectSettings = builderResult
      return returnMe
    }
    public func mergeFrom(other:ServerConnectSettings) throws -> ServerConnectSettings.Builder {
      if other == ServerConnectSettings() {
       return self
      }
      if other.hasHost {
           host = other.host
      }
      if other.hasPort {
           port = other.port
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFrom(codedInputStream:CodedInputStream) throws -> ServerConnectSettings.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ServerConnectSettings.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          host = try codedInputStream.readString()

        case 16:
          port = try codedInputStream.readUInt32()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ModemConfigurationCommand : GeneratedMessage {
  public fileprivate(set) var networkOperatorSettings:NetworkOperatorSettings!
  public fileprivate(set) var hasNetworkOperatorSettings:Bool = false
  public fileprivate(set) var networkDataSettings:NetworkDataSettings!
  public fileprivate(set) var hasNetworkDataSettings:Bool = false
  public fileprivate(set) var serverConnectSettings:ServerConnectSettings!
  public fileprivate(set) var hasServerConnectSettings:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream:CodedOutputStream) throws {
    if hasNetworkOperatorSettings {
      try codedOutputStream.writeMessage(fieldNumber:1, value:networkOperatorSettings)
    }
    if hasNetworkDataSettings {
      try codedOutputStream.writeMessage(fieldNumber:2, value:networkDataSettings)
    }
    if hasServerConnectSettings {
      try codedOutputStream.writeMessage(fieldNumber:3, value:serverConnectSettings)
    }
    try unknownFields.writeTo(codedOutputStream:codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasNetworkOperatorSettings {
        if let varSizenetworkOperatorSettings = networkOperatorSettings?.computeMessageSize(fieldNumber: 1) {
            serialize_size += varSizenetworkOperatorSettings
        }
    }
    if hasNetworkDataSettings {
        if let varSizenetworkDataSettings = networkDataSettings?.computeMessageSize(fieldNumber: 2) {
            serialize_size += varSizenetworkDataSettings
        }
    }
    if hasServerConnectSettings {
        if let varSizeserverConnectSettings = serverConnectSettings?.computeMessageSize(fieldNumber: 3) {
            serialize_size += varSizeserverConnectSettings
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> ModemConfigurationCommand.Builder {
    return ModemConfigurationCommand.classBuilder() as! ModemConfigurationCommand.Builder
  }
  public func getBuilder() -> ModemConfigurationCommand.Builder {
    return classBuilder() as! ModemConfigurationCommand.Builder
  }
  public override class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return ModemConfigurationCommand.Builder()
  }
  public override func classBuilder() -> ProtocolBuffersMessageBuilder {
    return ModemConfigurationCommand.Builder()
  }
  public func toBuilder() throws -> ModemConfigurationCommand.Builder {
    return try ModemConfigurationCommand.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:ModemConfigurationCommand) throws -> ModemConfigurationCommand.Builder {
    return try ModemConfigurationCommand.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasNetworkOperatorSettings {
      output += "\(indent) networkOperatorSettings {\n"
      if let outDescNetworkOperatorSettings = networkOperatorSettings {
        output += try outDescNetworkOperatorSettings.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasNetworkDataSettings {
      output += "\(indent) networkDataSettings {\n"
      if let outDescNetworkDataSettings = networkDataSettings {
        output += try outDescNetworkDataSettings.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasServerConnectSettings {
      output += "\(indent) serverConnectSettings {\n"
      if let outDescServerConnectSettings = serverConnectSettings {
        output += try outDescServerConnectSettings.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasNetworkOperatorSettings {
              if let hashValuenetworkOperatorSettings = networkOperatorSettings?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuenetworkOperatorSettings
              }
          }
          if hasNetworkDataSettings {
              if let hashValuenetworkDataSettings = networkDataSettings?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuenetworkDataSettings
              }
          }
          if hasServerConnectSettings {
              if let hashValueserverConnectSettings = serverConnectSettings?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueserverConnectSettings
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ModemConfigurationCommand"
  }
  override public func className() -> String {
      return "ModemConfigurationCommand"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ModemConfigurationCommand = ModemConfigurationCommand()
    public func getMessage() -> ModemConfigurationCommand {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasNetworkOperatorSettings:Bool {
         get {
             return builderResult.hasNetworkOperatorSettings
         }
    }
    public var networkOperatorSettings:NetworkOperatorSettings! {
         get {
             if networkOperatorSettingsBuilder_ != nil {
                builderResult.networkOperatorSettings = networkOperatorSettingsBuilder_.getMessage()
             }
             return builderResult.networkOperatorSettings
         }
         set (value) {
             builderResult.hasNetworkOperatorSettings = true
             builderResult.networkOperatorSettings = value
         }
    }
    private var networkOperatorSettingsBuilder_:NetworkOperatorSettings.Builder! {
         didSet {
            builderResult.hasNetworkOperatorSettings = true
         }
    }
    public func getNetworkOperatorSettingsBuilder() -> NetworkOperatorSettings.Builder {
      if networkOperatorSettingsBuilder_ == nil {
         networkOperatorSettingsBuilder_ = NetworkOperatorSettings.Builder()
         builderResult.networkOperatorSettings = networkOperatorSettingsBuilder_.getMessage()
         if networkOperatorSettings != nil {
            _ = try! networkOperatorSettingsBuilder_.mergeFrom(other: networkOperatorSettings)
         }
      }
      return networkOperatorSettingsBuilder_
    }
    public func setNetworkOperatorSettings(_ value:NetworkOperatorSettings!) -> ModemConfigurationCommand.Builder {
      self.networkOperatorSettings = value
      return self
    }
    public func mergeNetworkOperatorSettings(value:NetworkOperatorSettings) throws -> ModemConfigurationCommand.Builder {
      if builderResult.hasNetworkOperatorSettings {
        builderResult.networkOperatorSettings = try NetworkOperatorSettings.builderWithPrototype(prototype: builderResult.networkOperatorSettings).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.networkOperatorSettings = value
      }
      builderResult.hasNetworkOperatorSettings = true
      return self
    }
    public func clearNetworkOperatorSettings() -> ModemConfigurationCommand.Builder {
      networkOperatorSettingsBuilder_ = nil
      builderResult.hasNetworkOperatorSettings = false
      builderResult.networkOperatorSettings = nil
      return self
    }
    public var hasNetworkDataSettings:Bool {
         get {
             return builderResult.hasNetworkDataSettings
         }
    }
    public var networkDataSettings:NetworkDataSettings! {
         get {
             if networkDataSettingsBuilder_ != nil {
                builderResult.networkDataSettings = networkDataSettingsBuilder_.getMessage()
             }
             return builderResult.networkDataSettings
         }
         set (value) {
             builderResult.hasNetworkDataSettings = true
             builderResult.networkDataSettings = value
         }
    }
    private var networkDataSettingsBuilder_:NetworkDataSettings.Builder! {
         didSet {
            builderResult.hasNetworkDataSettings = true
         }
    }
    public func getNetworkDataSettingsBuilder() -> NetworkDataSettings.Builder {
      if networkDataSettingsBuilder_ == nil {
         networkDataSettingsBuilder_ = NetworkDataSettings.Builder()
         builderResult.networkDataSettings = networkDataSettingsBuilder_.getMessage()
         if networkDataSettings != nil {
            _ = try! networkDataSettingsBuilder_.mergeFrom(other: networkDataSettings)
         }
      }
      return networkDataSettingsBuilder_
    }
    public func setNetworkDataSettings(_ value:NetworkDataSettings!) -> ModemConfigurationCommand.Builder {
      self.networkDataSettings = value
      return self
    }
    public func mergeNetworkDataSettings(value:NetworkDataSettings) throws -> ModemConfigurationCommand.Builder {
      if builderResult.hasNetworkDataSettings {
        builderResult.networkDataSettings = try NetworkDataSettings.builderWithPrototype(prototype: builderResult.networkDataSettings).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.networkDataSettings = value
      }
      builderResult.hasNetworkDataSettings = true
      return self
    }
    public func clearNetworkDataSettings() -> ModemConfigurationCommand.Builder {
      networkDataSettingsBuilder_ = nil
      builderResult.hasNetworkDataSettings = false
      builderResult.networkDataSettings = nil
      return self
    }
    public var hasServerConnectSettings:Bool {
         get {
             return builderResult.hasServerConnectSettings
         }
    }
    public var serverConnectSettings:ServerConnectSettings! {
         get {
             if serverConnectSettingsBuilder_ != nil {
                builderResult.serverConnectSettings = serverConnectSettingsBuilder_.getMessage()
             }
             return builderResult.serverConnectSettings
         }
         set (value) {
             builderResult.hasServerConnectSettings = true
             builderResult.serverConnectSettings = value
         }
    }
    private var serverConnectSettingsBuilder_:ServerConnectSettings.Builder! {
         didSet {
            builderResult.hasServerConnectSettings = true
         }
    }
    public func getServerConnectSettingsBuilder() -> ServerConnectSettings.Builder {
      if serverConnectSettingsBuilder_ == nil {
         serverConnectSettingsBuilder_ = ServerConnectSettings.Builder()
         builderResult.serverConnectSettings = serverConnectSettingsBuilder_.getMessage()
         if serverConnectSettings != nil {
            _ = try! serverConnectSettingsBuilder_.mergeFrom(other: serverConnectSettings)
         }
      }
      return serverConnectSettingsBuilder_
    }
    public func setServerConnectSettings(_ value:ServerConnectSettings!) -> ModemConfigurationCommand.Builder {
      self.serverConnectSettings = value
      return self
    }
    public func mergeServerConnectSettings(value:ServerConnectSettings) throws -> ModemConfigurationCommand.Builder {
      if builderResult.hasServerConnectSettings {
        builderResult.serverConnectSettings = try ServerConnectSettings.builderWithPrototype(prototype: builderResult.serverConnectSettings).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.serverConnectSettings = value
      }
      builderResult.hasServerConnectSettings = true
      return self
    }
    public func clearServerConnectSettings() -> ModemConfigurationCommand.Builder {
      serverConnectSettingsBuilder_ = nil
      builderResult.hasServerConnectSettings = false
      builderResult.serverConnectSettings = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ModemConfigurationCommand.Builder {
      builderResult = ModemConfigurationCommand()
      return self
    }
    public override func clone() throws -> ModemConfigurationCommand.Builder {
      return try ModemConfigurationCommand.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> ModemConfigurationCommand {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ModemConfigurationCommand {
      let returnMe:ModemConfigurationCommand = builderResult
      return returnMe
    }
    public func mergeFrom(other:ModemConfigurationCommand) throws -> ModemConfigurationCommand.Builder {
      if other == ModemConfigurationCommand() {
       return self
      }
      if other.hasNetworkOperatorSettings {
          _ = try mergeNetworkOperatorSettings(value: other.networkOperatorSettings)
      }
      if other.hasNetworkDataSettings {
          _ = try mergeNetworkDataSettings(value: other.networkDataSettings)
      }
      if other.hasServerConnectSettings {
          _ = try mergeServerConnectSettings(value: other.serverConnectSettings)
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFrom(codedInputStream:CodedInputStream) throws -> ModemConfigurationCommand.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ModemConfigurationCommand.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          let subBuilder:NetworkOperatorSettings.Builder = NetworkOperatorSettings.Builder()
          if hasNetworkOperatorSettings {
           _ = try subBuilder.mergeFrom(other: networkOperatorSettings)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          networkOperatorSettings = subBuilder.buildPartial()

        case 18:
          let subBuilder:NetworkDataSettings.Builder = NetworkDataSettings.Builder()
          if hasNetworkDataSettings {
           _ = try subBuilder.mergeFrom(other: networkDataSettings)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          networkDataSettings = subBuilder.buildPartial()

        case 26:
          let subBuilder:ServerConnectSettings.Builder = ServerConnectSettings.Builder()
          if hasServerConnectSettings {
           _ = try subBuilder.mergeFrom(other: serverConnectSettings)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          serverConnectSettings = subBuilder.buildPartial()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class RtcconfigurationCommand : GeneratedMessage {
  public fileprivate(set) var unixTime:UInt32 = UInt32(0)

  public fileprivate(set) var hasUnixTime:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream:CodedOutputStream) throws {
    if hasUnixTime {
      try codedOutputStream.writeUInt32(fieldNumber:1, value:unixTime)
    }
    try unknownFields.writeTo(codedOutputStream:codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasUnixTime {
      serialize_size += unixTime.computeUInt32Size(fieldNumber: 1)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> RtcconfigurationCommand.Builder {
    return RtcconfigurationCommand.classBuilder() as! RtcconfigurationCommand.Builder
  }
  public func getBuilder() -> RtcconfigurationCommand.Builder {
    return classBuilder() as! RtcconfigurationCommand.Builder
  }
  public override class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return RtcconfigurationCommand.Builder()
  }
  public override func classBuilder() -> ProtocolBuffersMessageBuilder {
    return RtcconfigurationCommand.Builder()
  }
  public func toBuilder() throws -> RtcconfigurationCommand.Builder {
    return try RtcconfigurationCommand.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:RtcconfigurationCommand) throws -> RtcconfigurationCommand.Builder {
    return try RtcconfigurationCommand.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasUnixTime {
      output += "\(indent) unixTime: \(unixTime) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasUnixTime {
             hashCode = (hashCode &* 31) &+ unixTime.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "RtcconfigurationCommand"
  }
  override public func className() -> String {
      return "RtcconfigurationCommand"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:RtcconfigurationCommand = RtcconfigurationCommand()
    public func getMessage() -> RtcconfigurationCommand {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasUnixTime:Bool {
         get {
              return builderResult.hasUnixTime
         }
    }
    public var unixTime:UInt32 {
         get {
              return builderResult.unixTime
         }
         set (value) {
             builderResult.hasUnixTime = true
             builderResult.unixTime = value
         }
    }
    public func setUnixTime(_ value:UInt32) -> RtcconfigurationCommand.Builder {
      self.unixTime = value
      return self
    }
    public func clearUnixTime() -> RtcconfigurationCommand.Builder{
         builderResult.hasUnixTime = false
         builderResult.unixTime = UInt32(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> RtcconfigurationCommand.Builder {
      builderResult = RtcconfigurationCommand()
      return self
    }
    public override func clone() throws -> RtcconfigurationCommand.Builder {
      return try RtcconfigurationCommand.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> RtcconfigurationCommand {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> RtcconfigurationCommand {
      let returnMe:RtcconfigurationCommand = builderResult
      return returnMe
    }
    public func mergeFrom(other:RtcconfigurationCommand) throws -> RtcconfigurationCommand.Builder {
      if other == RtcconfigurationCommand() {
       return self
      }
      if other.hasUnixTime {
           unixTime = other.unixTime
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFrom(codedInputStream:CodedInputStream) throws -> RtcconfigurationCommand.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RtcconfigurationCommand.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          unixTime = try codedInputStream.readUInt32()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class CommandResponse : GeneratedMessage {
  public fileprivate(set) var type:ControlCommand.Types = .version
  public fileprivate(set) var hasType:Bool = false
  public fileprivate(set) var message:String = ""

  public fileprivate(set) var hasMessage:Bool = false
  public fileprivate(set) var status:Bool = false

  public fileprivate(set) var hasStatus:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream:CodedOutputStream) throws {
    if hasType {
      try codedOutputStream.writeEnum(fieldNumber:1, value:type.rawValue)
    }
    if hasMessage {
      try codedOutputStream.writeString(fieldNumber:2, value:message)
    }
    if hasStatus {
      try codedOutputStream.writeBool(fieldNumber:3, value:status)
    }
    try unknownFields.writeTo(codedOutputStream:codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasType) {
      serialize_size += type.rawValue.computeEnumSize(fieldNumber: 1)
    }
    if hasMessage {
      serialize_size += message.computeStringSize(fieldNumber: 2)
    }
    if hasStatus {
      serialize_size += status.computeBoolSize(fieldNumber: 3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> CommandResponse.Builder {
    return CommandResponse.classBuilder() as! CommandResponse.Builder
  }
  public func getBuilder() -> CommandResponse.Builder {
    return classBuilder() as! CommandResponse.Builder
  }
  public override class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return CommandResponse.Builder()
  }
  public override func classBuilder() -> ProtocolBuffersMessageBuilder {
    return CommandResponse.Builder()
  }
  public func toBuilder() throws -> CommandResponse.Builder {
    return try CommandResponse.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:CommandResponse) throws -> CommandResponse.Builder {
    return try CommandResponse.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if (hasType) {
      output += "\(indent) type: \(type.description)\n"
    }
    if hasMessage {
      output += "\(indent) message: \(message) \n"
    }
    if hasStatus {
      output += "\(indent) status: \(status) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasType {
             hashCode = (hashCode &* 31) &+ Int(type.rawValue)
          }
          if hasMessage {
             hashCode = (hashCode &* 31) &+ message.hashValue
          }
          if hasStatus {
             hashCode = (hashCode &* 31) &+ status.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "CommandResponse"
  }
  override public func className() -> String {
      return "CommandResponse"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:CommandResponse = CommandResponse()
    public func getMessage() -> CommandResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasType:Bool{
          get {
              return builderResult.hasType
          }
      }
      public var type:ControlCommand.Types {
          get {
              return builderResult.type
          }
          set (value) {
              builderResult.hasType = true
              builderResult.type = value
          }
      }
      public func setType(_ value:ControlCommand.Types) -> CommandResponse.Builder {
        self.type = value
        return self
      }
      public func clearType() -> CommandResponse.Builder {
         builderResult.hasType = false
         builderResult.type = .version
         return self
      }
    public var hasMessage:Bool {
         get {
              return builderResult.hasMessage
         }
    }
    public var message:String {
         get {
              return builderResult.message
         }
         set (value) {
             builderResult.hasMessage = true
             builderResult.message = value
         }
    }
    public func setMessage(_ value:String) -> CommandResponse.Builder {
      self.message = value
      return self
    }
    public func clearMessage() -> CommandResponse.Builder{
         builderResult.hasMessage = false
         builderResult.message = ""
         return self
    }
    public var hasStatus:Bool {
         get {
              return builderResult.hasStatus
         }
    }
    public var status:Bool {
         get {
              return builderResult.status
         }
         set (value) {
             builderResult.hasStatus = true
             builderResult.status = value
         }
    }
    public func setStatus(_ value:Bool) -> CommandResponse.Builder {
      self.status = value
      return self
    }
    public func clearStatus() -> CommandResponse.Builder{
         builderResult.hasStatus = false
         builderResult.status = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> CommandResponse.Builder {
      builderResult = CommandResponse()
      return self
    }
    public override func clone() throws -> CommandResponse.Builder {
      return try CommandResponse.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> CommandResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> CommandResponse {
      let returnMe:CommandResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:CommandResponse) throws -> CommandResponse.Builder {
      if other == CommandResponse() {
       return self
      }
      if other.hasType {
           type = other.type
      }
      if other.hasMessage {
           message = other.message
      }
      if other.hasStatus {
           status = other.status
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFrom(codedInputStream:CodedInputStream) throws -> CommandResponse.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CommandResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueInttype = try codedInputStream.readEnum()
          if let enumstype = ControlCommand.Types.init(rawValue: valueInttype){
               type = enumstype
          } else {
            _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueInttype))
          }

        case 18:
          message = try codedInputStream.readString()

        case 24:
          status = try codedInputStream.readBool()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class DiagnosticRequest : GeneratedMessage {


    //Enum type declaration start 

    public enum DecodedType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case `none` = 1
      case obd2 = 2

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
        switch self {
        case .`none`: return ".`none`"
        case .obd2: return ".obd2"
        }
      }
    }

    //Enum type declaration end 

  public fileprivate(set) var bus:Int32 = Int32(0)

  public fileprivate(set) var hasBus:Bool = false
  public fileprivate(set) var messageId:UInt32 = UInt32(0)

  public fileprivate(set) var hasMessageId:Bool = false
  public fileprivate(set) var mode:UInt32 = UInt32(0)

  public fileprivate(set) var hasMode:Bool = false
  public fileprivate(set) var pid:UInt32 = UInt32(0)

  public fileprivate(set) var hasPid:Bool = false
  // TODO we are capping this at 8 bytes for now - need to change when we
  // support multi-frame responses
  public fileprivate(set) var payload:Data = Data()

  public fileprivate(set) var hasPayload:Bool = false
  public fileprivate(set) var multipleResponses:Bool = false

  public fileprivate(set) var hasMultipleResponses:Bool = false
  public fileprivate(set) var frequency:Double = Double(0)

  public fileprivate(set) var hasFrequency:Bool = false
  public fileprivate(set) var name:String = ""

  public fileprivate(set) var hasName:Bool = false
  public fileprivate(set) var decodedType:DiagnosticRequest.DecodedType = DiagnosticRequest.DecodedType.`none`
  public fileprivate(set) var hasDecodedType:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream:CodedOutputStream) throws {
    if hasBus {
      try codedOutputStream.writeInt32(fieldNumber:1, value:bus)
    }
    if hasMessageId {
      try codedOutputStream.writeUInt32(fieldNumber:2, value:messageId)
    }
    if hasMode {
      try codedOutputStream.writeUInt32(fieldNumber:3, value:mode)
    }
    if hasPid {
      try codedOutputStream.writeUInt32(fieldNumber:4, value:pid)
    }
    if hasPayload {
      try codedOutputStream.writeData(fieldNumber:5, value:payload)
    }
    if hasMultipleResponses {
      try codedOutputStream.writeBool(fieldNumber:6, value:multipleResponses)
    }
    if hasFrequency {
      try codedOutputStream.writeDouble(fieldNumber:7, value:frequency)
    }
    if hasName {
      try codedOutputStream.writeString(fieldNumber:8, value:name)
    }
    if hasDecodedType {
      try codedOutputStream.writeEnum(fieldNumber:9, value:decodedType.rawValue)
    }
    try unknownFields.writeTo(codedOutputStream:codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasBus {
      serialize_size += bus.computeInt32Size(fieldNumber: 1)
    }
    if hasMessageId {
      serialize_size += messageId.computeUInt32Size(fieldNumber: 2)
    }
    if hasMode {
      serialize_size += mode.computeUInt32Size(fieldNumber: 3)
    }
    if hasPid {
      serialize_size += pid.computeUInt32Size(fieldNumber: 4)
    }
    if hasPayload {
      serialize_size += payload.computeDataSize(fieldNumber: 5)
    }
    if hasMultipleResponses {
      serialize_size += multipleResponses.computeBoolSize(fieldNumber: 6)
    }
    if hasFrequency {
      serialize_size += frequency.computeDoubleSize(fieldNumber: 7)
    }
    if hasName {
      serialize_size += name.computeStringSize(fieldNumber: 8)
    }
    if (hasDecodedType) {
      serialize_size += decodedType.rawValue.computeEnumSize(fieldNumber: 9)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> DiagnosticRequest.Builder {
    return DiagnosticRequest.classBuilder() as! DiagnosticRequest.Builder
  }
  public func getBuilder() -> DiagnosticRequest.Builder {
    return classBuilder() as! DiagnosticRequest.Builder
  }
  public override class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return DiagnosticRequest.Builder()
  }
  public override func classBuilder() -> ProtocolBuffersMessageBuilder {
    return DiagnosticRequest.Builder()
  }
  public func toBuilder() throws -> DiagnosticRequest.Builder {
    return try DiagnosticRequest.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:DiagnosticRequest) throws -> DiagnosticRequest.Builder {
    return try DiagnosticRequest.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasBus {
      output += "\(indent) bus: \(bus) \n"
    }
    if hasMessageId {
      output += "\(indent) messageId: \(messageId) \n"
    }
    if hasMode {
      output += "\(indent) mode: \(mode) \n"
    }
    if hasPid {
      output += "\(indent) pid: \(pid) \n"
    }
    if hasPayload {
      output += "\(indent) payload: \(payload) \n"
    }
    if hasMultipleResponses {
      output += "\(indent) multipleResponses: \(multipleResponses) \n"
    }
    if hasFrequency {
      output += "\(indent) frequency: \(frequency) \n"
    }
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if (hasDecodedType) {
      output += "\(indent) decodedType: \(decodedType.description)\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasBus {
             hashCode = (hashCode &* 31) &+ bus.hashValue
          }
          if hasMessageId {
             hashCode = (hashCode &* 31) &+ messageId.hashValue
          }
          if hasMode {
             hashCode = (hashCode &* 31) &+ mode.hashValue
          }
          if hasPid {
             hashCode = (hashCode &* 31) &+ pid.hashValue
          }
          if hasPayload {
             hashCode = (hashCode &* 31) &+ payload.hashValue
          }
          if hasMultipleResponses {
             hashCode = (hashCode &* 31) &+ multipleResponses.hashValue
          }
          if hasFrequency {
             hashCode = (hashCode &* 31) &+ frequency.hashValue
          }
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasDecodedType {
             hashCode = (hashCode &* 31) &+ Int(decodedType.rawValue)
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DiagnosticRequest"
  }
  override public func className() -> String {
      return "DiagnosticRequest"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:DiagnosticRequest = DiagnosticRequest()
    public func getMessage() -> DiagnosticRequest {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasBus:Bool {
         get {
              return builderResult.hasBus
         }
    }
    public var bus:Int32 {
         get {
              return builderResult.bus
         }
         set (value) {
             builderResult.hasBus = true
             builderResult.bus = value
         }
    }
    public func setBus(_ value:Int32) -> DiagnosticRequest.Builder {
      self.bus = value
      return self
    }
    public func clearBus() -> DiagnosticRequest.Builder{
         builderResult.hasBus = false
         builderResult.bus = Int32(0)
         return self
    }
    public var hasMessageId:Bool {
         get {
              return builderResult.hasMessageId
         }
    }
    public var messageId:UInt32 {
         get {
              return builderResult.messageId
         }
         set (value) {
             builderResult.hasMessageId = true
             builderResult.messageId = value
         }
    }
    public func setMessageId(_ value:UInt32) -> DiagnosticRequest.Builder {
      self.messageId = value
      return self
    }
    public func clearMessageId() -> DiagnosticRequest.Builder{
         builderResult.hasMessageId = false
         builderResult.messageId = UInt32(0)
         return self
    }
    public var hasMode:Bool {
         get {
              return builderResult.hasMode
         }
    }
    public var mode:UInt32 {
         get {
              return builderResult.mode
         }
         set (value) {
             builderResult.hasMode = true
             builderResult.mode = value
         }
    }
    public func setMode(_ value:UInt32) -> DiagnosticRequest.Builder {
      self.mode = value
      return self
    }
    public func clearMode() -> DiagnosticRequest.Builder{
         builderResult.hasMode = false
         builderResult.mode = UInt32(0)
         return self
    }
    public var hasPid:Bool {
         get {
              return builderResult.hasPid
         }
    }
    public var pid:UInt32 {
         get {
              return builderResult.pid
         }
         set (value) {
             builderResult.hasPid = true
             builderResult.pid = value
         }
    }
    public func setPid(_ value:UInt32) -> DiagnosticRequest.Builder {
      self.pid = value
      return self
    }
    public func clearPid() -> DiagnosticRequest.Builder{
         builderResult.hasPid = false
         builderResult.pid = UInt32(0)
         return self
    }
    public var hasPayload:Bool {
         get {
              return builderResult.hasPayload
         }
    }
    public var payload:Data {
         get {
              return builderResult.payload
         }
         set (value) {
             builderResult.hasPayload = true
             builderResult.payload = value
         }
    }
    public func setPayload(_ value:Data) -> DiagnosticRequest.Builder {
      self.payload = value
      return self
    }
    public func clearPayload() -> DiagnosticRequest.Builder{
         builderResult.hasPayload = false
         builderResult.payload = Data()
         return self
    }
    public var hasMultipleResponses:Bool {
         get {
              return builderResult.hasMultipleResponses
         }
    }
    public var multipleResponses:Bool {
         get {
              return builderResult.multipleResponses
         }
         set (value) {
             builderResult.hasMultipleResponses = true
             builderResult.multipleResponses = value
         }
    }
    public func setMultipleResponses(_ value:Bool) -> DiagnosticRequest.Builder {
      self.multipleResponses = value
      return self
    }
    public func clearMultipleResponses() -> DiagnosticRequest.Builder{
         builderResult.hasMultipleResponses = false
         builderResult.multipleResponses = false
         return self
    }
    public var hasFrequency:Bool {
         get {
              return builderResult.hasFrequency
         }
    }
    public var frequency:Double {
         get {
              return builderResult.frequency
         }
         set (value) {
             builderResult.hasFrequency = true
             builderResult.frequency = value
         }
    }
    public func setFrequency(_ value:Double) -> DiagnosticRequest.Builder {
      self.frequency = value
      return self
    }
    public func clearFrequency() -> DiagnosticRequest.Builder{
         builderResult.hasFrequency = false
         builderResult.frequency = Double(0)
         return self
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(_ value:String) -> DiagnosticRequest.Builder {
      self.name = value
      return self
    }
    public func clearName() -> DiagnosticRequest.Builder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
      public var hasDecodedType:Bool{
          get {
              return builderResult.hasDecodedType
          }
      }
      public var decodedType:DiagnosticRequest.DecodedType {
          get {
              return builderResult.decodedType
          }
          set (value) {
              builderResult.hasDecodedType = true
              builderResult.decodedType = value
          }
      }
      public func setDecodedType(_ value:DiagnosticRequest.DecodedType) -> DiagnosticRequest.Builder {
        self.decodedType = value
        return self
      }
      public func clearDecodedType() -> DiagnosticRequest.Builder {
         builderResult.hasDecodedType = false
         builderResult.decodedType = .`none`
         return self
      }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> DiagnosticRequest.Builder {
      builderResult = DiagnosticRequest()
      return self
    }
    public override func clone() throws -> DiagnosticRequest.Builder {
      return try DiagnosticRequest.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> DiagnosticRequest {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DiagnosticRequest {
      let returnMe:DiagnosticRequest = builderResult
      return returnMe
    }
    public func mergeFrom(other:DiagnosticRequest) throws -> DiagnosticRequest.Builder {
      if other == DiagnosticRequest() {
       return self
      }
      if other.hasBus {
           bus = other.bus
      }
      if other.hasMessageId {
           messageId = other.messageId
      }
      if other.hasMode {
           mode = other.mode
      }
      if other.hasPid {
           pid = other.pid
      }
      if other.hasPayload {
           payload = other.payload
      }
      if other.hasMultipleResponses {
           multipleResponses = other.multipleResponses
      }
      if other.hasFrequency {
           frequency = other.frequency
      }
      if other.hasName {
           name = other.name
      }
      if other.hasDecodedType {
           decodedType = other.decodedType
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFrom(codedInputStream:CodedInputStream) throws -> DiagnosticRequest.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DiagnosticRequest.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          bus = try codedInputStream.readInt32()

        case 16:
          messageId = try codedInputStream.readUInt32()

        case 24:
          mode = try codedInputStream.readUInt32()

        case 32:
          pid = try codedInputStream.readUInt32()

        case 42:
          payload = try codedInputStream.readData()

        case 48:
          multipleResponses = try codedInputStream.readBool()

        case 57:
          frequency = try codedInputStream.readDouble()

        case 66:
          name = try codedInputStream.readString()

        case 72:
          let valueIntdecodedType = try codedInputStream.readEnum()
          if let enumsdecodedType = DiagnosticRequest.DecodedType(rawValue:valueIntdecodedType){
               decodedType = enumsdecodedType
          } else {
            _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 9, value:Int64(valueIntdecodedType))
          }

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class DiagnosticResponse : GeneratedMessage {
  public fileprivate(set) var bus:Int32 = Int32(0)

  public fileprivate(set) var hasBus:Bool = false
  public fileprivate(set) var messageId:UInt32 = UInt32(0)

  public fileprivate(set) var hasMessageId:Bool = false
  public fileprivate(set) var mode:UInt32 = UInt32(0)

  public fileprivate(set) var hasMode:Bool = false
  public fileprivate(set) var pid:UInt32 = UInt32(0)

  public fileprivate(set) var hasPid:Bool = false
  public fileprivate(set) var success:Bool = false

  public fileprivate(set) var hasSuccess:Bool = false
  public fileprivate(set) var negativeResponseCode:UInt32 = UInt32(0)

  public fileprivate(set) var hasNegativeResponseCode:Bool = false
  // TODO we are capping this at 8 bytes for now - need to change when we
  // support multi-frame responses
  public fileprivate(set) var payload:Data = Data()

  public fileprivate(set) var hasPayload:Bool = false
  public fileprivate(set) var value:Double = Double(0)

  public fileprivate(set) var hasValue:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream:CodedOutputStream) throws {
    if hasBus {
      try codedOutputStream.writeInt32(fieldNumber:1, value:bus)
    }
    if hasMessageId {
      try codedOutputStream.writeUInt32(fieldNumber:2, value:messageId)
    }
    if hasMode {
      try codedOutputStream.writeUInt32(fieldNumber:3, value:mode)
    }
    if hasPid {
      try codedOutputStream.writeUInt32(fieldNumber:4, value:pid)
    }
    if hasSuccess {
      try codedOutputStream.writeBool(fieldNumber:5, value:success)
    }
    if hasNegativeResponseCode {
      try codedOutputStream.writeUInt32(fieldNumber:6, value:negativeResponseCode)
    }
    if hasPayload {
      try codedOutputStream.writeData(fieldNumber:7, value:payload)
    }
    if hasValue {
      try codedOutputStream.writeDouble(fieldNumber:8, value:value)
    }
    try unknownFields.writeTo(codedOutputStream:codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasBus {
      serialize_size += bus.computeInt32Size(fieldNumber: 1)
    }
    if hasMessageId {
      serialize_size += messageId.computeUInt32Size(fieldNumber: 2)
    }
    if hasMode {
      serialize_size += mode.computeUInt32Size(fieldNumber: 3)
    }
    if hasPid {
      serialize_size += pid.computeUInt32Size(fieldNumber: 4)
    }
    if hasSuccess {
      serialize_size += success.computeBoolSize(fieldNumber: 5)
    }
    if hasNegativeResponseCode {
      serialize_size += negativeResponseCode.computeUInt32Size(fieldNumber: 6)
    }
    if hasPayload {
      serialize_size += payload.computeDataSize(fieldNumber: 7)
    }
    if hasValue {
      serialize_size += value.computeDoubleSize(fieldNumber: 8)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> DiagnosticResponse.Builder {
    return DiagnosticResponse.classBuilder() as! DiagnosticResponse.Builder
  }
  public func getBuilder() -> DiagnosticResponse.Builder {
    return classBuilder() as! DiagnosticResponse.Builder
  }
  public override class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return DiagnosticResponse.Builder()
  }
  public override func classBuilder() -> ProtocolBuffersMessageBuilder {
    return DiagnosticResponse.Builder()
  }
  public func toBuilder() throws -> DiagnosticResponse.Builder {
    return try DiagnosticResponse.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:DiagnosticResponse) throws -> DiagnosticResponse.Builder {
    return try DiagnosticResponse.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasBus {
      output += "\(indent) bus: \(bus) \n"
    }
    if hasMessageId {
      output += "\(indent) messageId: \(messageId) \n"
    }
    if hasMode {
      output += "\(indent) mode: \(mode) \n"
    }
    if hasPid {
      output += "\(indent) pid: \(pid) \n"
    }
    if hasSuccess {
      output += "\(indent) success: \(success) \n"
    }
    if hasNegativeResponseCode {
      output += "\(indent) negativeResponseCode: \(negativeResponseCode) \n"
    }
    if hasPayload {
      output += "\(indent) payload: \(payload) \n"
    }
    if hasValue {
      output += "\(indent) value: \(value) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasBus {
             hashCode = (hashCode &* 31) &+ bus.hashValue
          }
          if hasMessageId {
             hashCode = (hashCode &* 31) &+ messageId.hashValue
          }
          if hasMode {
             hashCode = (hashCode &* 31) &+ mode.hashValue
          }
          if hasPid {
             hashCode = (hashCode &* 31) &+ pid.hashValue
          }
          if hasSuccess {
             hashCode = (hashCode &* 31) &+ success.hashValue
          }
          if hasNegativeResponseCode {
             hashCode = (hashCode &* 31) &+ negativeResponseCode.hashValue
          }
          if hasPayload {
             hashCode = (hashCode &* 31) &+ payload.hashValue
          }
          if hasValue {
             hashCode = (hashCode &* 31) &+ value.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DiagnosticResponse"
  }
  override public func className() -> String {
      return "DiagnosticResponse"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:DiagnosticResponse = DiagnosticResponse()
    public func getMessage() -> DiagnosticResponse {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasBus:Bool {
         get {
              return builderResult.hasBus
         }
    }
    public var bus:Int32 {
         get {
              return builderResult.bus
         }
         set (value) {
             builderResult.hasBus = true
             builderResult.bus = value
         }
    }
    public func setBus(_ value:Int32) -> DiagnosticResponse.Builder {
      self.bus = value
      return self
    }
    public func clearBus() -> DiagnosticResponse.Builder{
         builderResult.hasBus = false
         builderResult.bus = Int32(0)
         return self
    }
    public var hasMessageId:Bool {
         get {
              return builderResult.hasMessageId
         }
    }
    public var messageId:UInt32 {
         get {
              return builderResult.messageId
         }
         set (value) {
             builderResult.hasMessageId = true
             builderResult.messageId = value
         }
    }
    public func setMessageId(_ value:UInt32) -> DiagnosticResponse.Builder {
      self.messageId = value
      return self
    }
    public func clearMessageId() -> DiagnosticResponse.Builder{
         builderResult.hasMessageId = false
         builderResult.messageId = UInt32(0)
         return self
    }
    public var hasMode:Bool {
         get {
              return builderResult.hasMode
         }
    }
    public var mode:UInt32 {
         get {
              return builderResult.mode
         }
         set (value) {
             builderResult.hasMode = true
             builderResult.mode = value
         }
    }
    public func setMode(_ value:UInt32) -> DiagnosticResponse.Builder {
      self.mode = value
      return self
    }
    public func clearMode() -> DiagnosticResponse.Builder{
         builderResult.hasMode = false
         builderResult.mode = UInt32(0)
         return self
    }
    public var hasPid:Bool {
         get {
              return builderResult.hasPid
         }
    }
    public var pid:UInt32 {
         get {
              return builderResult.pid
         }
         set (value) {
             builderResult.hasPid = true
             builderResult.pid = value
         }
    }
    public func setPid(_ value:UInt32) -> DiagnosticResponse.Builder {
      self.pid = value
      return self
    }
    public func clearPid() -> DiagnosticResponse.Builder{
         builderResult.hasPid = false
         builderResult.pid = UInt32(0)
         return self
    }
    public var hasSuccess:Bool {
         get {
              return builderResult.hasSuccess
         }
    }
    public var success:Bool {
         get {
              return builderResult.success
         }
         set (value) {
             builderResult.hasSuccess = true
             builderResult.success = value
         }
    }
    public func setSuccess(_ value:Bool) -> DiagnosticResponse.Builder {
      self.success = value
      return self
    }
    public func clearSuccess() -> DiagnosticResponse.Builder{
         builderResult.hasSuccess = false
         builderResult.success = false
         return self
    }
    public var hasNegativeResponseCode:Bool {
         get {
              return builderResult.hasNegativeResponseCode
         }
    }
    public var negativeResponseCode:UInt32 {
         get {
              return builderResult.negativeResponseCode
         }
         set (value) {
             builderResult.hasNegativeResponseCode = true
             builderResult.negativeResponseCode = value
         }
    }
    public func setNegativeResponseCode(_ value:UInt32) -> DiagnosticResponse.Builder {
      self.negativeResponseCode = value
      return self
    }
    public func clearNegativeResponseCode() -> DiagnosticResponse.Builder{
         builderResult.hasNegativeResponseCode = false
         builderResult.negativeResponseCode = UInt32(0)
         return self
    }
    public var hasPayload:Bool {
         get {
              return builderResult.hasPayload
         }
    }
    public var payload:Data {
         get {
              return builderResult.payload
         }
         set (value) {
             builderResult.hasPayload = true
             builderResult.payload = value
         }
    }
    public func setPayload(_ value:Data) -> DiagnosticResponse.Builder {
      self.payload = value
      return self
    }
    public func clearPayload() -> DiagnosticResponse.Builder{
         builderResult.hasPayload = false
         builderResult.payload = Data()
         return self
    }
    public var hasValue:Bool {
         get {
              return builderResult.hasValue
         }
    }
    public var value:Double {
         get {
              return builderResult.value
         }
         set (value) {
             builderResult.hasValue = true
             builderResult.value = value
         }
    }
    public func setValue(_ value:Double) -> DiagnosticResponse.Builder {
      self.value = value
      return self
    }
    public func clearValue() -> DiagnosticResponse.Builder{
         builderResult.hasValue = false
         builderResult.value = Double(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> DiagnosticResponse.Builder {
      builderResult = DiagnosticResponse()
      return self
    }
    public override func clone() throws -> DiagnosticResponse.Builder {
      return try DiagnosticResponse.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> DiagnosticResponse {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DiagnosticResponse {
      let returnMe:DiagnosticResponse = builderResult
      return returnMe
    }
    public func mergeFrom(other:DiagnosticResponse) throws -> DiagnosticResponse.Builder {
      if other == DiagnosticResponse() {
       return self
      }
      if other.hasBus {
           bus = other.bus
      }
      if other.hasMessageId {
           messageId = other.messageId
      }
      if other.hasMode {
           mode = other.mode
      }
      if other.hasPid {
           pid = other.pid
      }
      if other.hasSuccess {
           success = other.success
      }
      if other.hasNegativeResponseCode {
           negativeResponseCode = other.negativeResponseCode
      }
      if other.hasPayload {
           payload = other.payload
      }
      if other.hasValue {
           value = other.value
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFrom(codedInputStream:CodedInputStream) throws -> DiagnosticResponse.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DiagnosticResponse.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          bus = try codedInputStream.readInt32()

        case 16:
          messageId = try codedInputStream.readUInt32()

        case 24:
          mode = try codedInputStream.readUInt32()

        case 32:
          pid = try codedInputStream.readUInt32()

        case 40:
          success = try codedInputStream.readBool()

        case 48:
          negativeResponseCode = try codedInputStream.readUInt32()

        case 58:
          payload = try codedInputStream.readData()

        case 65:
          value = try codedInputStream.readDouble()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class DynamicField : GeneratedMessage {


    //Enum type declaration start 

    public enum Types:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case string = 1
      case num = 2
      case bool = 3

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
        switch self {
        case .string: return ".string"
        case .num: return ".num"
        case .bool: return ".bool"
        }
      }
    }

    //Enum type declaration end 

  public fileprivate(set) var type:DynamicField.Types = .string
  public fileprivate(set) var hasType:Bool = false
  public fileprivate(set) var stringValue:String = ""

  public fileprivate(set) var hasStringValue:Bool = false
  public fileprivate(set) var numericValue:Double = Double(0)

  public fileprivate(set) var hasNumericValue:Bool = false
  public fileprivate(set) var booleanValue:Bool = false

  public fileprivate(set) var hasBooleanValue:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream:CodedOutputStream) throws {
    if hasType {
      try codedOutputStream.writeEnum(fieldNumber:1, value:type.rawValue)
    }
    if hasStringValue {
      try codedOutputStream.writeString(fieldNumber:2, value:stringValue)
    }
    if hasNumericValue {
      try codedOutputStream.writeDouble(fieldNumber:3, value:numericValue)
    }
    if hasBooleanValue {
      try codedOutputStream.writeBool(fieldNumber:4, value:booleanValue)
    }
    try unknownFields.writeTo(codedOutputStream:codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if (hasType) {
      serialize_size += type.rawValue.computeEnumSize(fieldNumber: 1)
    }
    if hasStringValue {
      serialize_size += stringValue.computeStringSize(fieldNumber: 2)
    }
    if hasNumericValue {
      serialize_size += numericValue.computeDoubleSize(fieldNumber: 3)
    }
    if hasBooleanValue {
      serialize_size += booleanValue.computeBoolSize(fieldNumber: 4)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> DynamicField.Builder {
    return DynamicField.classBuilder() as! DynamicField.Builder
  }
  public func getBuilder() -> DynamicField.Builder {
    return classBuilder() as! DynamicField.Builder
  }
  public override class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return DynamicField.Builder()
  }
  public override func classBuilder() -> ProtocolBuffersMessageBuilder {
    return DynamicField.Builder()
  }
  public func toBuilder() throws -> DynamicField.Builder {
    return try DynamicField.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:DynamicField) throws -> DynamicField.Builder {
    return try DynamicField.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if (hasType) {
      output += "\(indent) type: \(type.description)\n"
    }
    if hasStringValue {
      output += "\(indent) stringValue: \(stringValue) \n"
    }
    if hasNumericValue {
      output += "\(indent) numericValue: \(numericValue) \n"
    }
    if hasBooleanValue {
      output += "\(indent) booleanValue: \(booleanValue) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasType {
             hashCode = (hashCode &* 31) &+ Int(type.rawValue)
          }
          if hasStringValue {
             hashCode = (hashCode &* 31) &+ stringValue.hashValue
          }
          if hasNumericValue {
             hashCode = (hashCode &* 31) &+ numericValue.hashValue
          }
          if hasBooleanValue {
             hashCode = (hashCode &* 31) &+ booleanValue.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DynamicField"
  }
  override public func className() -> String {
      return "DynamicField"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:DynamicField = DynamicField()
    public func getMessage() -> DynamicField {
        return builderResult
    }

    required override public init () {
       super.init()
    }
      public var hasType:Bool{
          get {
              return builderResult.hasType
          }
      }
      public var type:DynamicField.Types {
          get {
              return builderResult.type
          }
          set (value) {
              builderResult.hasType = true
              builderResult.type = value
          }
      }
      public func setType(_ value:DynamicField.Types) -> DynamicField.Builder {
        self.type = value
        return self
      }
      public func clearType() -> DynamicField.Builder {
         builderResult.hasType = false
         builderResult.type = .string
         return self
      }
    public var hasStringValue:Bool {
         get {
              return builderResult.hasStringValue
         }
    }
    public var stringValue:String {
         get {
              return builderResult.stringValue
         }
         set (value) {
             builderResult.hasStringValue = true
             builderResult.stringValue = value
         }
    }
    public func setStringValue(_ value:String) -> DynamicField.Builder {
      self.stringValue = value
      return self
    }
    public func clearStringValue() -> DynamicField.Builder{
         builderResult.hasStringValue = false
         builderResult.stringValue = ""
         return self
    }
    public var hasNumericValue:Bool {
         get {
              return builderResult.hasNumericValue
         }
    }
    public var numericValue:Double {
         get {
              return builderResult.numericValue
         }
         set (value) {
             builderResult.hasNumericValue = true
             builderResult.numericValue = value
         }
    }
    public func setNumericValue(_ value:Double) -> DynamicField.Builder {
      self.numericValue = value
      return self
    }
    public func clearNumericValue() -> DynamicField.Builder{
         builderResult.hasNumericValue = false
         builderResult.numericValue = Double(0)
         return self
    }
    public var hasBooleanValue:Bool {
         get {
              return builderResult.hasBooleanValue
         }
    }
    public var booleanValue:Bool {
         get {
              return builderResult.booleanValue
         }
         set (value) {
             builderResult.hasBooleanValue = true
             builderResult.booleanValue = value
         }
    }
    public func setBooleanValue(_ value:Bool) -> DynamicField.Builder {
      self.booleanValue = value
      return self
    }
    public func clearBooleanValue() -> DynamicField.Builder{
         builderResult.hasBooleanValue = false
         builderResult.booleanValue = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> DynamicField.Builder {
      builderResult = DynamicField()
      return self
    }
    public override func clone() throws -> DynamicField.Builder {
      return try DynamicField.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> DynamicField {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> DynamicField {
      let returnMe:DynamicField = builderResult
      return returnMe
    }
    public func mergeFrom(other:DynamicField) throws -> DynamicField.Builder {
      if other == DynamicField() {
       return self
      }
      if other.hasType {
           type = other.type
      }
      if other.hasStringValue {
           stringValue = other.stringValue
      }
      if other.hasNumericValue {
           numericValue = other.numericValue
      }
      if other.hasBooleanValue {
           booleanValue = other.booleanValue
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFrom(codedInputStream:CodedInputStream) throws -> DynamicField.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DynamicField.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          let valueInttype = try codedInputStream.readEnum()
          if let enumstype = DynamicField.Types.init(rawValue: valueInttype){
               type = enumstype
          } else {
            _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueInttype))
          }

        case 18:
          stringValue = try codedInputStream.readString()

        case 25:
          numericValue = try codedInputStream.readDouble()

        case 32:
          booleanValue = try codedInputStream.readBool()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class SimpleMessage : GeneratedMessage {
  public fileprivate(set) var name:String = ""

  public fileprivate(set) var hasName:Bool = false
  public fileprivate(set) var value:DynamicField!
  public fileprivate(set) var hasValue:Bool = false
  public fileprivate(set) var event:DynamicField!
  public fileprivate(set) var hasEvent:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream:CodedOutputStream) throws {
    if hasName {
      try codedOutputStream.writeString(fieldNumber:1, value:name)
    }
    if hasValue {
      try codedOutputStream.writeMessage(fieldNumber:2, value:value)
    }
    if hasEvent {
      try codedOutputStream.writeMessage(fieldNumber:3, value:event)
    }
    try unknownFields.writeTo(codedOutputStream:codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasName {
      serialize_size += name.computeStringSize(fieldNumber: 1)
    }
    if hasValue {
        if let varSizevalue = value?.computeMessageSize(fieldNumber: 2) {
            serialize_size += varSizevalue
        }
    }
    if hasEvent {
        if let varSizeevent = event?.computeMessageSize(fieldNumber: 3) {
            serialize_size += varSizeevent
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> SimpleMessage.Builder {
    return SimpleMessage.classBuilder() as! SimpleMessage.Builder
  }
  public func getBuilder() -> SimpleMessage.Builder {
    return classBuilder() as! SimpleMessage.Builder
  }
  public override class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return SimpleMessage.Builder()
  }
  public override func classBuilder() -> ProtocolBuffersMessageBuilder {
    return SimpleMessage.Builder()
  }
  public func toBuilder() throws -> SimpleMessage.Builder {
    return try SimpleMessage.builderWithPrototype(prototype: self)
  }
  public class func builderWithPrototype(prototype:SimpleMessage) throws -> SimpleMessage.Builder {
    return try SimpleMessage.Builder().mergeFrom(other: prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if hasValue {
      output += "\(indent) value {\n"
      if let outDescValue = value {
        output += try outDescValue.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasEvent {
      output += "\(indent) event {\n"
      if let outDescEvent = event {
        output += try outDescEvent.getDescription(indent:"\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasValue {
              if let hashValuevalue = value?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuevalue
              }
          }
          if hasEvent {
              if let hashValueevent = event?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueevent
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "SimpleMessage"
  }
  override public func className() -> String {
      return "SimpleMessage"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:SimpleMessage = SimpleMessage()
    public func getMessage() -> SimpleMessage {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(_ value:String) -> SimpleMessage.Builder {
      self.name = value
      return self
    }
    public func clearName() -> SimpleMessage.Builder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    public var hasValue:Bool {
         get {
             return builderResult.hasValue
         }
    }
    public var value:DynamicField! {
         get {
             if valueBuilder_ != nil {
                builderResult.value = valueBuilder_.getMessage()
             }
             return builderResult.value
         }
         set (value) {
             builderResult.hasValue = true
             builderResult.value = value
         }
    }
    private var valueBuilder_:DynamicField.Builder! {
         didSet {
            builderResult.hasValue = true
         }
    }
    public func getValueBuilder() -> DynamicField.Builder {
      if valueBuilder_ == nil {
         valueBuilder_ = DynamicField.Builder()
         builderResult.value = valueBuilder_.getMessage()
         if value != nil {
            _ = try! valueBuilder_.mergeFrom(other: value)
         }
      }
      return valueBuilder_
    }
    public func setValue(_ value:DynamicField!) -> SimpleMessage.Builder {
      self.value = value
      return self
    }
    public func mergeValue(value:DynamicField) throws -> SimpleMessage.Builder {
      if builderResult.hasValue {
        builderResult.value = try DynamicField.builderWithPrototype(prototype: builderResult.value).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.value = value
      }
      builderResult.hasValue = true
      return self
    }
    public func clearValue() -> SimpleMessage.Builder {
      valueBuilder_ = nil
      builderResult.hasValue = false
      builderResult.value = nil
      return self
    }
    public var hasEvent:Bool {
         get {
             return builderResult.hasEvent
         }
    }
    public var event:DynamicField! {
         get {
             if eventBuilder_ != nil {
                builderResult.event = eventBuilder_.getMessage()
             }
             return builderResult.event
         }
         set (value) {
             builderResult.hasEvent = true
             builderResult.event = value
         }
    }
    private var eventBuilder_:DynamicField.Builder! {
         didSet {
            builderResult.hasEvent = true
         }
    }
    public func getEventBuilder() -> DynamicField.Builder {
      if eventBuilder_ == nil {
         eventBuilder_ = DynamicField.Builder()
         builderResult.event = eventBuilder_.getMessage()
         if event != nil {
            _ = try! eventBuilder_.mergeFrom(other: event)
         }
      }
      return eventBuilder_
    }
    public func setEvent(_ value:DynamicField!) -> SimpleMessage.Builder {
      self.event = value
      return self
    }
    public func mergeEvent(value:DynamicField) throws -> SimpleMessage.Builder {
      if builderResult.hasEvent {
        builderResult.event = try DynamicField.builderWithPrototype(prototype: builderResult.event).mergeFrom(other: value).buildPartial()
      } else {
        builderResult.event = value
      }
      builderResult.hasEvent = true
      return self
    }
    public func clearEvent() -> SimpleMessage.Builder {
      eventBuilder_ = nil
      builderResult.hasEvent = false
      builderResult.event = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> SimpleMessage.Builder {
      builderResult = SimpleMessage()
      return self
    }
    public override func clone() throws -> SimpleMessage.Builder {
      return try SimpleMessage.builderWithPrototype(prototype: builderResult)
    }
    public override func build() throws -> SimpleMessage {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> SimpleMessage {
      let returnMe:SimpleMessage = builderResult
      return returnMe
    }
    public func mergeFrom(other:SimpleMessage) throws -> SimpleMessage.Builder {
      if other == SimpleMessage() {
       return self
      }
      if other.hasName {
           name = other.name
      }
      if other.hasValue {
          _ = try mergeValue(value: other.value)
      }
      if other.hasEvent {
          _ = try mergeEvent(value: other.event)
      }
      _ = try merge(unknownField: other.unknownFields)
      return self
    }
    public override func mergeFrom(codedInputStream:CodedInputStream) throws -> SimpleMessage.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SimpleMessage.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom: self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10:
          name = try codedInputStream.readString()

        case 18:
          let subBuilder:DynamicField.Builder = DynamicField.Builder()
          if hasValue {
           _ = try subBuilder.mergeFrom(other: value)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          value = subBuilder.buildPartial()

        case 26:
          let subBuilder:DynamicField.Builder = DynamicField.Builder()
          if hasEvent {
           _ = try subBuilder.mergeFrom(other: event)
          }
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          event = subBuilder.buildPartial()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

extension VehicleMessage: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream:InputStream) throws -> Array<VehicleMessage> {
    var mergedArray = Array<VehicleMessage>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream:InputStream) throws -> VehicleMessage? {
    return try VehicleMessage.Builder().mergeDelimitedFrom(inputStream:inputStream)?.build()
  }
  public class func parseFrom(data:Data) throws -> VehicleMessage {
    return try VehicleMessage.Builder().mergeFrom(data: data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data:Data, extensionRegistry:ExtensionRegistry) throws -> VehicleMessage {
    return try VehicleMessage.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream:InputStream) throws -> VehicleMessage {
    return try VehicleMessage.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> VehicleMessage {
    return try VehicleMessage.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream) throws -> VehicleMessage {
    return try VehicleMessage.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VehicleMessage {
    return try VehicleMessage.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension CanMessage: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream:InputStream) throws -> Array<CanMessage> {
    var mergedArray = Array<CanMessage>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream:InputStream) throws -> CanMessage? {
    return try CanMessage.Builder().mergeDelimitedFrom(inputStream:inputStream)?.build()
  }
  public class func parseFrom(data:Data) throws -> CanMessage {
    return try CanMessage.Builder().mergeFrom(data: data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data:Data, extensionRegistry:ExtensionRegistry) throws -> CanMessage {
    return try CanMessage.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream:InputStream) throws -> CanMessage {
    return try CanMessage.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> CanMessage {
    return try CanMessage.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream) throws -> CanMessage {
    return try CanMessage.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CanMessage {
    return try CanMessage.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension ControlCommand: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream:InputStream) throws -> Array<ControlCommand> {
    var mergedArray = Array<ControlCommand>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream:InputStream) throws -> ControlCommand? {
    return try ControlCommand.Builder().mergeDelimitedFrom(inputStream:inputStream)?.build()
  }
  public class func parseFrom(data:Data) throws -> ControlCommand {
    return try ControlCommand.Builder().mergeFrom(data: data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data:Data, extensionRegistry:ExtensionRegistry) throws -> ControlCommand {
    return try ControlCommand.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream:InputStream) throws -> ControlCommand {
    return try ControlCommand.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> ControlCommand {
    return try ControlCommand.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream) throws -> ControlCommand {
    return try ControlCommand.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ControlCommand {
    return try ControlCommand.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension DiagnosticControlCommand: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream:InputStream) throws -> Array<DiagnosticControlCommand> {
    var mergedArray = Array<DiagnosticControlCommand>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream:InputStream) throws -> DiagnosticControlCommand? {
    return try DiagnosticControlCommand.Builder().mergeDelimitedFrom(inputStream:inputStream)?.build()
  }
  public class func parseFrom(data:Data) throws -> DiagnosticControlCommand {
    return try DiagnosticControlCommand.Builder().mergeFrom(data: data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data:Data, extensionRegistry:ExtensionRegistry) throws -> DiagnosticControlCommand {
    return try DiagnosticControlCommand.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream:InputStream) throws -> DiagnosticControlCommand {
    return try DiagnosticControlCommand.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> DiagnosticControlCommand {
    return try DiagnosticControlCommand.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream) throws -> DiagnosticControlCommand {
    return try DiagnosticControlCommand.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DiagnosticControlCommand {
    return try DiagnosticControlCommand.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension PassthroughModeControlCommand: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream:InputStream) throws -> Array<PassthroughModeControlCommand> {
    var mergedArray = Array<PassthroughModeControlCommand>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream:InputStream) throws -> PassthroughModeControlCommand? {
    return try PassthroughModeControlCommand.Builder().mergeDelimitedFrom(inputStream:inputStream)?.build()
  }
  public class func parseFrom(data:Data) throws -> PassthroughModeControlCommand {
    return try PassthroughModeControlCommand.Builder().mergeFrom(data: data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data:Data, extensionRegistry:ExtensionRegistry) throws -> PassthroughModeControlCommand {
    return try PassthroughModeControlCommand.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream:InputStream) throws -> PassthroughModeControlCommand {
    return try PassthroughModeControlCommand.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> PassthroughModeControlCommand {
    return try PassthroughModeControlCommand.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream) throws -> PassthroughModeControlCommand {
    return try PassthroughModeControlCommand.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PassthroughModeControlCommand {
    return try PassthroughModeControlCommand.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension AcceptanceFilterBypassCommand: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream:InputStream) throws -> Array<AcceptanceFilterBypassCommand> {
    var mergedArray = Array<AcceptanceFilterBypassCommand>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream:InputStream) throws -> AcceptanceFilterBypassCommand? {
    return try AcceptanceFilterBypassCommand.Builder().mergeDelimitedFrom(inputStream:inputStream)?.build()
  }
  public class func parseFrom(data:Data) throws -> AcceptanceFilterBypassCommand {
    return try AcceptanceFilterBypassCommand.Builder().mergeFrom(data: data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data:Data, extensionRegistry:ExtensionRegistry) throws -> AcceptanceFilterBypassCommand {
    return try AcceptanceFilterBypassCommand.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream:InputStream) throws -> AcceptanceFilterBypassCommand {
    return try AcceptanceFilterBypassCommand.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> AcceptanceFilterBypassCommand {
    return try AcceptanceFilterBypassCommand.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream) throws -> AcceptanceFilterBypassCommand {
    return try AcceptanceFilterBypassCommand.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AcceptanceFilterBypassCommand {
    return try AcceptanceFilterBypassCommand.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension PayloadFormatCommand: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream:InputStream) throws -> Array<PayloadFormatCommand> {
    var mergedArray = Array<PayloadFormatCommand>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream:InputStream) throws -> PayloadFormatCommand? {
    return try PayloadFormatCommand.Builder().mergeDelimitedFrom(inputStream:inputStream)?.build()
  }
  public class func parseFrom(data:Data) throws -> PayloadFormatCommand {
    return try PayloadFormatCommand.Builder().mergeFrom(data: data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data:Data, extensionRegistry:ExtensionRegistry) throws -> PayloadFormatCommand {
    return try PayloadFormatCommand.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream:InputStream) throws -> PayloadFormatCommand {
    return try PayloadFormatCommand.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> PayloadFormatCommand {
    return try PayloadFormatCommand.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream) throws -> PayloadFormatCommand {
    return try PayloadFormatCommand.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PayloadFormatCommand {
    return try PayloadFormatCommand.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension PredefinedObd2RequestsCommand: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream:InputStream) throws -> Array<PredefinedObd2RequestsCommand> {
    var mergedArray = Array<PredefinedObd2RequestsCommand>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream:InputStream) throws -> PredefinedObd2RequestsCommand? {
    return try PredefinedObd2RequestsCommand.Builder().mergeDelimitedFrom(inputStream:inputStream)?.build()
  }
  public class func parseFrom(data:Data) throws -> PredefinedObd2RequestsCommand {
    return try PredefinedObd2RequestsCommand.Builder().mergeFrom(data: data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data:Data, extensionRegistry:ExtensionRegistry) throws -> PredefinedObd2RequestsCommand {
    return try PredefinedObd2RequestsCommand.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream:InputStream) throws -> PredefinedObd2RequestsCommand {
    return try PredefinedObd2RequestsCommand.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> PredefinedObd2RequestsCommand {
    return try PredefinedObd2RequestsCommand.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream) throws -> PredefinedObd2RequestsCommand {
    return try PredefinedObd2RequestsCommand.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> PredefinedObd2RequestsCommand {
    return try PredefinedObd2RequestsCommand.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension NetworkOperatorSettings: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream:InputStream) throws -> Array<NetworkOperatorSettings> {
    var mergedArray = Array<NetworkOperatorSettings>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream:InputStream) throws -> NetworkOperatorSettings? {
    return try NetworkOperatorSettings.Builder().mergeDelimitedFrom(inputStream:inputStream)?.build()
  }
  public class func parseFrom(data:Data) throws -> NetworkOperatorSettings {
    return try NetworkOperatorSettings.Builder().mergeFrom(data: data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data:Data, extensionRegistry:ExtensionRegistry) throws -> NetworkOperatorSettings {
    return try NetworkOperatorSettings.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream:InputStream) throws -> NetworkOperatorSettings {
    return try NetworkOperatorSettings.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> NetworkOperatorSettings {
    return try NetworkOperatorSettings.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream) throws -> NetworkOperatorSettings {
    return try NetworkOperatorSettings.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> NetworkOperatorSettings {
    return try NetworkOperatorSettings.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension NetworkOperatorSettings.NetworkDescriptor: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream:InputStream) throws -> Array<NetworkOperatorSettings.NetworkDescriptor> {
    var mergedArray = Array<NetworkOperatorSettings.NetworkDescriptor>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream:InputStream) throws -> NetworkOperatorSettings.NetworkDescriptor? {
    return try NetworkOperatorSettings.NetworkDescriptor.Builder().mergeDelimitedFrom(inputStream:inputStream)?.build()
  }
  public class func parseFrom(data:Data) throws -> NetworkOperatorSettings.NetworkDescriptor {
    return try NetworkOperatorSettings.NetworkDescriptor.Builder().mergeFrom(data: data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data:Data, extensionRegistry:ExtensionRegistry) throws -> NetworkOperatorSettings.NetworkDescriptor {
    return try NetworkOperatorSettings.NetworkDescriptor.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream:InputStream) throws -> NetworkOperatorSettings.NetworkDescriptor {
    return try NetworkOperatorSettings.NetworkDescriptor.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> NetworkOperatorSettings.NetworkDescriptor {
    return try NetworkOperatorSettings.NetworkDescriptor.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream) throws -> NetworkOperatorSettings.NetworkDescriptor {
    return try NetworkOperatorSettings.NetworkDescriptor.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> NetworkOperatorSettings.NetworkDescriptor {
    return try NetworkOperatorSettings.NetworkDescriptor.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension NetworkDataSettings: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream:InputStream) throws -> Array<NetworkDataSettings> {
    var mergedArray = Array<NetworkDataSettings>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream:InputStream) throws -> NetworkDataSettings? {
    return try NetworkDataSettings.Builder().mergeDelimitedFrom(inputStream:inputStream)?.build()
  }
  public class func parseFrom(data:Data) throws -> NetworkDataSettings {
    return try NetworkDataSettings.Builder().mergeFrom(data: data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data:Data, extensionRegistry:ExtensionRegistry) throws -> NetworkDataSettings {
    return try NetworkDataSettings.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream:InputStream) throws -> NetworkDataSettings {
    return try NetworkDataSettings.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> NetworkDataSettings {
    return try NetworkDataSettings.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream) throws -> NetworkDataSettings {
    return try NetworkDataSettings.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> NetworkDataSettings {
    return try NetworkDataSettings.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension ServerConnectSettings: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream:InputStream) throws -> Array<ServerConnectSettings> {
    var mergedArray = Array<ServerConnectSettings>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream:InputStream) throws -> ServerConnectSettings? {
    return try ServerConnectSettings.Builder().mergeDelimitedFrom(inputStream:inputStream)?.build()
  }
  public class func parseFrom(data:Data) throws -> ServerConnectSettings {
    return try ServerConnectSettings.Builder().mergeFrom(data: data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data:Data, extensionRegistry:ExtensionRegistry) throws -> ServerConnectSettings {
    return try ServerConnectSettings.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream:InputStream) throws -> ServerConnectSettings {
    return try ServerConnectSettings.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> ServerConnectSettings {
    return try ServerConnectSettings.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream) throws -> ServerConnectSettings {
    return try ServerConnectSettings.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ServerConnectSettings {
    return try ServerConnectSettings.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension ModemConfigurationCommand: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream:InputStream) throws -> Array<ModemConfigurationCommand> {
    var mergedArray = Array<ModemConfigurationCommand>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream:InputStream) throws -> ModemConfigurationCommand? {
    return try ModemConfigurationCommand.Builder().mergeDelimitedFrom(inputStream:inputStream)?.build()
  }
  public class func parseFrom(data:Data) throws -> ModemConfigurationCommand {
    return try ModemConfigurationCommand.Builder().mergeFrom(data: data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data:Data, extensionRegistry:ExtensionRegistry) throws -> ModemConfigurationCommand {
    return try ModemConfigurationCommand.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream:InputStream) throws -> ModemConfigurationCommand {
    return try ModemConfigurationCommand.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> ModemConfigurationCommand {
    return try ModemConfigurationCommand.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream) throws -> ModemConfigurationCommand {
    return try ModemConfigurationCommand.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ModemConfigurationCommand {
    return try ModemConfigurationCommand.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension RtcconfigurationCommand: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream:InputStream) throws -> Array<RtcconfigurationCommand> {
    var mergedArray = Array<RtcconfigurationCommand>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream:InputStream) throws -> RtcconfigurationCommand? {
    return try RtcconfigurationCommand.Builder().mergeDelimitedFrom(inputStream:inputStream)?.build()
  }
  public class func parseFrom(data:Data) throws -> RtcconfigurationCommand {
    return try RtcconfigurationCommand.Builder().mergeFrom(data: data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data:Data, extensionRegistry:ExtensionRegistry) throws -> RtcconfigurationCommand {
    return try RtcconfigurationCommand.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream:InputStream) throws -> RtcconfigurationCommand {
    return try RtcconfigurationCommand.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> RtcconfigurationCommand {
    return try RtcconfigurationCommand.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream) throws -> RtcconfigurationCommand {
    return try RtcconfigurationCommand.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RtcconfigurationCommand {
    return try RtcconfigurationCommand.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension CommandResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream:InputStream) throws -> Array<CommandResponse> {
    var mergedArray = Array<CommandResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream:InputStream) throws -> CommandResponse? {
    return try CommandResponse.Builder().mergeDelimitedFrom(inputStream:inputStream)?.build()
  }
  public class func parseFrom(data:Data) throws -> CommandResponse {
    return try CommandResponse.Builder().mergeFrom(data: data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data:Data, extensionRegistry:ExtensionRegistry) throws -> CommandResponse {
    return try CommandResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream:InputStream) throws -> CommandResponse {
    return try CommandResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> CommandResponse {
    return try CommandResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream) throws -> CommandResponse {
    return try CommandResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> CommandResponse {
    return try CommandResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension DiagnosticRequest: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream:InputStream) throws -> Array<DiagnosticRequest> {
    var mergedArray = Array<DiagnosticRequest>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream:InputStream) throws -> DiagnosticRequest? {
    return try DiagnosticRequest.Builder().mergeDelimitedFrom(inputStream:inputStream)?.build()
  }
  public class func parseFrom(data:Data) throws -> DiagnosticRequest {
    return try DiagnosticRequest.Builder().mergeFrom(data: data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data:Data, extensionRegistry:ExtensionRegistry) throws -> DiagnosticRequest {
    return try DiagnosticRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream:InputStream) throws -> DiagnosticRequest {
    return try DiagnosticRequest.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> DiagnosticRequest {
    return try DiagnosticRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream) throws -> DiagnosticRequest {
    return try DiagnosticRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DiagnosticRequest {
    return try DiagnosticRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension DiagnosticResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream:InputStream) throws -> Array<DiagnosticResponse> {
    var mergedArray = Array<DiagnosticResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream:InputStream) throws -> DiagnosticResponse? {
    return try DiagnosticResponse.Builder().mergeDelimitedFrom(inputStream:inputStream)?.build()
  }
  public class func parseFrom(data:Data) throws -> DiagnosticResponse {
    return try DiagnosticResponse.Builder().mergeFrom(data: data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data:Data, extensionRegistry:ExtensionRegistry) throws -> DiagnosticResponse {
    return try DiagnosticResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream:InputStream) throws -> DiagnosticResponse {
    return try DiagnosticResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> DiagnosticResponse {
    return try DiagnosticResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream) throws -> DiagnosticResponse {
    return try DiagnosticResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DiagnosticResponse {
    return try DiagnosticResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension DynamicField: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream:InputStream) throws -> Array<DynamicField> {
    var mergedArray = Array<DynamicField>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream:InputStream) throws -> DynamicField? {
    return try DynamicField.Builder().mergeDelimitedFrom(inputStream:inputStream)?.build()
  }
  public class func parseFrom(data:Data) throws -> DynamicField {
    return try DynamicField.Builder().mergeFrom(data: data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data:Data, extensionRegistry:ExtensionRegistry) throws -> DynamicField {
    return try DynamicField.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream:InputStream) throws -> DynamicField {
    return try DynamicField.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> DynamicField {
    return try DynamicField.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream) throws -> DynamicField {
    return try DynamicField.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> DynamicField {
    return try DynamicField.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension SimpleMessage: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream:InputStream) throws -> Array<SimpleMessage> {
    var mergedArray = Array<SimpleMessage>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream:InputStream) throws -> SimpleMessage? {
    return try SimpleMessage.Builder().mergeDelimitedFrom(inputStream:inputStream)?.build()
  }
  public class func parseFrom(data:Data) throws -> SimpleMessage {
    return try SimpleMessage.Builder().mergeFrom(data: data, extensionRegistry:OpenxcRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFrom(data:Data, extensionRegistry:ExtensionRegistry) throws -> SimpleMessage {
    return try SimpleMessage.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream:InputStream) throws -> SimpleMessage {
    return try SimpleMessage.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream:InputStream, extensionRegistry:ExtensionRegistry) throws -> SimpleMessage {
    return try SimpleMessage.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream) throws -> SimpleMessage {
    return try SimpleMessage.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SimpleMessage {
    return try SimpleMessage.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}

// @@protoc_insertion_point(global_scope)
